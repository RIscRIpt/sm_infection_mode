/*
 * Infection game mode for ShootMania Storm
 * Copyright В© 2017 RIscRIpt
 *
 * This script is highly modificated, and fully rewritten
 * version of the mewin's script which can be found
 * on his website: https://mewin.de/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License v3 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const Version    "2017-02-22"
#Const ScriptName "Infection.Script.txt"

//TODO: move all scores logic to a separate library

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Scores
#Include "Libs/Nadeo/ScoresTable2.Script.txt" as ST
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/RIscRIpt/InfectionTree.Script.txt" as ITree

#Command Command_SetWarmup                  (Text)      as "<hidden>"

#Setting S_HorizontalInfectionDistance      0.61        as "<hidden>" //as "horizontal infection distance"
#Setting S_VerticalInfectionDistance        2.16        as "<hidden>" //as "vertical infection distance"
#Setting S_SphericalInfectionDistance       -1.0 /*1.30384*/ as "<hidden>" //as "spherical infection distance"
#Setting S_InfectionScore                   4           as "infection score"
#Setting S_InfectionArmorBonus              1           as "armor bonus for infection"
#Setting S_PVP                              False       as "enable PvP for survivors"
#Setting S_PursuitMode                      False       as "pursuit mode (need round restart)"
#Setting S_UsePVPCollisions                 False       as "use PvP collisions (need round restart)"
#Setting S_UseClans                         True        as "use teams (need map restart)"
#Setting S_UseSameWallJump                  False       as "allow escalator jump (need round restart)"
#Setting S_RespawnOnInfection               True        as "respawn on infection (need `use teams` == False)"
#Setting S_HitSurvivorScore                 0           as "hit survivor score (for PvP mode)"
#Setting S_HitInfectedScore                 1           as "hit infected score"
#Setting S_ScoreForSurv1Inf                 1           as "score for surviving single infection"
#Setting S_TimeLimit                        300000      as "time limit for a round"
#Setting S_ScoreLimit                       100         as "score limit for a match"
#Setting S_RoundLimit                       0           as "round limit for a match"
#Setting S_InfectedShoot                    1           as "allow first N infected to shoot"
#Setting S_InfectedAmmoGain                 1.0         as "infected ammo gain"
#Setting S_InfectedLaserMax                 0           as "<hidden>"
#Setting S_InfectedRocketMax                1           as "infected maximum rockets"
#Setting S_InfectedNucleusMax               0           as "<hidden>"
#Setting S_InfectedArrowMax                 0           as "<hidden>"
#Setting S_SurvivorAmmoGain                 1.0         as "survivor ammo gain"
#Setting S_SurvivorLaserMax                 1           as "<hidden>"
#Setting S_SurvivorRocketMax                4           as "survivor maximum rockets"
#Setting S_SurvivorNucleusMax               1           as "<hidden>"
#Setting S_SurvivorArrowMax                 2           as "<hidden>"
#Setting S_PreparationTime                  10000       as "time till first infection"
#Setting S_InfectNewPlayers                 True        as "<hidden>" //as "infect new players"
#Setting S_RewardInfectors                  0.5         as "<hidden>" //as "rewarding infected `parent` cooef."
#Setting S_SurvivorStamina                  1.0         as "survivor stamina (0.1-3.0)"
#Setting S_SurvivorStaminaGain              0.7         as "survivor stamina gain (0.0-1.0,10)"
#Setting S_InfectedStamina                  2.0         as "infected stamina (0.1-3.0)"
#Setting S_InfectedStaminaGain              1.0         as "infected stamina gain (0.0-1.0,10)"
#Setting S_SurvivorRespawnArmor             1           as "survivor respawn armor"
#Setting S_SurvivorMaxArmor                 1           as "survivor maximum armor"
#Setting S_InfectedRespawnArmor             2           as "infected respawn armor"
#Setting S_InfectedMaxArmor                 2           as "infected maximum armor"
#Setting S_RewardFirstInfected              0.5         as "<hidden>" //as ""
#Setting S_SurvivorDetectorMaxDist          20.0        as "survivor detector max distance"
#Setting S_RespawnDelay                     1000        as "<hidden>" //as "respawn delay"
#Setting S_CanLeaveMapFor                   3000        as "can leave battlefield for (ms)"
#Setting S_ForceSpecAfter                   60000       as "force inactive players to spectators after (ms)"
#Setting S_CanIdleAfterSpawn                10000       as "player can be idle after spawning for (ms)"
#Setting S_InfectOnPreparationRespawn       True        as "infect on respawn during preparation"
#Setting S_ForceFirstInfected               False       as "choose first infected even if someone got infected"

#Const   C_MaxSignedInteger                 2147483647

#Const   C_ModeInfection                    "Infection"
#Const   C_ModePursuit                      "Pursuit"

#Const   C_MinimalPlayerCount               2
#Const   C_InfectOnRespawn                  True        //as "infect on respawn"
#Const   C_InfectionTick                    30
#Const   C_SurvivorColor                    <1.0, 0.0, 0.0>
#Const   C_SurvivorHasShield                True
#Const   C_SurvivorIsHighlighted            True
#Const   C_SurvivorEnergyLevel              1.0
#Const   C_InfectedColor                    <0.0, 0.5, 0.0>
#Const   C_InfectedHasShield                True
#Const   C_InfectedIsHighlighted            False
#Const   C_InfectedEnergyLevel              1.0
#Const   C_RoundPauseTime                   4000
#Const   C_MatchPauseTime                   6000

#Const   C_MainManialinkLayer               "Infection_MainManialinkLayer"

#Const   C_SurvivorTeamId                   0
#Const   C_InfectedTeamId                   1
#Const   C_SurvivorClanNum                  1
#Const   C_InfectedClanNum                  2

#Const   C_TxtUnkTime                       "--:--.--"
#Const   C_TxtSurvivor                      "$f00Survivor"
#Const   C_TxtInfected                      "$080Infected"
#Const   C_TxtSpectator                     "$aaaSpectator"

#Const   C_TxtInfectedBy                    "Infected by: "
#Const   C_TxtInfectedFooter                "Infect $f00survivors$z!"
#Const   C_TxtSurvivorFooter                "Avoid $080infected $zplayers!"
#Const   C_TxtSpectatorFooter               ""

#Const   C_TopHits                          "Hits"
#Const   C_TitleTopHits                     "Top Hits"
#Const   C_TopInfections                    "Infs"
#Const   C_TitleTopInfections               "Top Infections"
#Const   C_TopSurivals                      "Srvs"
#Const   C_TitleTopSurvivals                "Top Survivals"

#Const   C_TxtRules                         "Free for all. You spawn as a survivor, if you die you respawn infected. Infected can infect other players by touching them."
#Const   C_TxtRoundEnd                      "A round ends either if no survivors are left or if the time limit is reached."

#Const   C_PlayerIsIdle                     "$z$s is idle."
#Const   C_WasIdleTooLongMovingToSpec       "$z$s was idle for too long. Moving to spectators."
#Const   C_IdlePlayerWarning                "$sYou are considered inactive!"

#Const   C_TxtYouInfectedA                  "$0f0You infected $fff%1"
#Const   C_TxtAInfectedYou                  "%1 $z$s$0f0infected you"
#Const   C_TxtAInfectedB                    "%1 $z$sinfected %2"

#Const   C_TxtPlayerDrowned                 "$z$s drowned in water!"
#Const   C_TxtPlayerInfectedByWater         "%1 $z$swas infected by water!"
#Const   C_TxtPlayerWasEliminated           "%1 $z$swas very curious and got aids!"

#Const   C_TxtAllPlayersInfected            "All players are infected!"
#Const   C_TxtTimeLimitReached              "Time limit reached!"
#Const   C_TxtNPlayersSurvivied             "$f00%1 $fffplayer(s) survived!"
#Const   C_TxtNoMoreInfected                "No more infected players!"
#Const   C_TxtAtLeastNPlayersNeeded         "At least $f00%1$z players are needed!"
#Const   C_TxtWaitingPlayers                "$f92Waiting for Players"

#Const   C_TxtGetBackToBattleField          "Get back to the battlefield!"
#Const   C_TxtYouWillBeInfectedInX          "You will be infected in $080%1"

#Const   C_LastSurvivorMsgDuration          6000
#Const   C_LastSurvivorMsgPriority          2

#Const   C_ArmorUnit                        100
#Const   C_ArmorReplenishGain               300

#Const   C_StaminaRealUnit                  1.0
#Const   C_StaminaIntUnit                   3600
#Const   C_StaminaMinGain                   0.0
#Const   C_StaminaMaxGain                   1.0

#Const   C_Cond_TxtPrefix                   "$f00[CondLandmark] $z$s"

#Const   C_Cond_CountSource                 0
#Const   C_Cond_Comparison                  1
#Const   C_Cond_Value                       2
#Const   C_Cond_Chain                       3

#Const   C_Cond_TxtPlayers                  "P"
#Const   C_Cond_TxtSurvivors                "S"
#Const   C_Cond_TxtInfected                 "I"

#Const   C_Cond_Players                     0
#Const   C_Cond_Survivors                   1
#Const   C_Cond_Infected                    2

#Const   C_Cond_Comparison_LT               0
#Const   C_Cond_Comparison_EQ               1
#Const   C_Cond_Comparison_GT               2

#Const   C_Cond_Chain_None                  -1
#Const   C_Cond_Chain_AND                   0
#Const   C_Cond_Chain_OR                    1

#Const   C_MapSetting_Water                         "W"
#Const   C_MapSetting_WaterProperty_TxtEliminates   "E"
#Const   C_MapSetting_WaterProperty_TxtProtects     "P"
#Const   C_MapSetting_WaterProperty_TxtInfects      "I"
#Const   C_MapSetting_WaterProperty_TxtHeals        "H"

#Const   C_UnexpectedBehaviour "Unexpected behaviour!\nThis must not happen!\nWhere: %1\nData: %2"

#Const   C_ST_Columns                   2
#Const   C_ST_Rows                      8

#Const   C_ST_Scale                     0.95
#Const   C_ST_Size_Header               <-1.0, -1.0>
#Const   C_ST_Size_Contents             <-1.0, -1.0>
#Const   C_ST_Size_Footer               <-1.0, -1.0>

#Const   C_ST_Color_Survivor            <0.5, 0.1, 0.1>
#Const   C_ST_Color_Infected            <0.1, 0.5, 0.1>

#Const   C_ST_Col_Id_Status             "Stts"
#Const   C_ST_Col_Id_SurvivalTime       "SrvT"
#Const   C_ST_Col_Id_Infections         "Infs"
#Const   C_ST_Col_Id_Hits               "Hits"
#Const   C_ST_Col_Id_Survivals          "Srvs"

#Const   C_ST_Col_Legend_Status         "Status"
#Const   C_ST_Col_Legend_SurvivalTime   "Survival Time"
#Const   C_ST_Col_Legend_Infections     "Inf"
#Const   C_ST_Col_Legend_Hits           "Hit"
#Const   C_ST_Col_Legend_Survivals      "Srv"

#Const   C_ST_Col_DefVal_Status         "$f00Survivor"
#Const   C_ST_Col_DefVal_SurvivalTime   "--:--.--"
#Const   C_ST_Col_DefVal_Infections     "$0800"
#Const   C_ST_Col_DefVal_Hits           "$f000"
#Const   C_ST_Col_DefVal_Survivals      "$ff00"

#Const   C_ST_Col_Width_Status          8.0
#Const   C_ST_Col_Width_SurvivalTime    8.0
#Const   C_ST_Col_Width_Infections      1.8
#Const   C_ST_Col_Width_Hits            1.8
#Const   C_ST_Col_Width_Survivals       1.8

#Const   C_ST_Col_Weight_Status         50.0
#Const   C_ST_Col_Weight_SurvivalTime   60.0
#Const   C_ST_Col_Weight_Infections     70.0
#Const   C_ST_Col_Weight_Hits           71.0
#Const   C_ST_Col_Weight_Survivals      72.0

#Const   C_ST_Col_Align_Status          CMlControl::AlignHorizontal::Left
#Const   C_ST_Col_Align_SurvivalTime    CMlControl::AlignHorizontal::HCenter
#Const   C_ST_Col_Align_Infections      CMlControl::AlignHorizontal::Right
#Const   C_ST_Col_Align_Hits            CMlControl::AlignHorizontal::HCenter
#Const   C_ST_Col_Align_Survivals       CMlControl::AlignHorizontal::Left

#Const   C_Inf_XmlRpc_InfectByLogin     "Inf_Infect"
#Const   C_Inf_XmlClb_Infected          "Inf_Infection"

/* -------------------------------------- */
// Globals
/* -------------------------------------- */

declare Boolean G_IsWarmup;
declare Boolean G_RestartingMatch;

declare Integer G_PrevPlayerProcTime;
declare Boolean G_InfectionStarted;

declare Integer G_InfectedPlayerCount;
declare Ident   G_FirstInfectedId;

declare CSmMapLandmark[] G_CondGates_Up_Always;
declare CSmMapLandmark[] G_CondGates_Up_EachRound;

declare CSmMapLandmark[] G_AllSpawns;
declare CSmMapLandmark[] G_SurvivorSpawns;
declare CSmMapLandmark[] G_InfectedSpawns;

// No bitfield operations, so declaring bunch of booleans
declare Boolean G_MapSetting_WaterHasEffects;

declare Boolean G_MapSetting_WaterForSurvivors_Eliminates;
declare Boolean G_MapSetting_WaterForSurvivors_Protects;
declare Boolean G_MapSetting_WaterForSurvivors_Infects;
declare Boolean G_MapSetting_WaterForSurvivors_Heals;

declare Boolean G_MapSetting_WaterForInfected_Eliminates;
declare Boolean G_MapSetting_WaterForInfected_Protects;
declare Boolean G_MapSetting_WaterForInfected_Heals;

***LogVersion***
***
MB_LogVersion(ScriptName                   , Version);
MB_LogVersion(Layers::GetScriptName()      , Layers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName()     , Message::GetScriptVersion());
MB_LogVersion(Top::GetScriptName()         , Top::GetScriptVersion());
MB_LogVersion(Tabs::GetScriptName()        , Tabs::GetScriptVersion());
MB_LogVersion(SM::GetScriptName()          , SM::GetScriptVersion());
MB_LogVersion(Scores::GetScriptName()      , Scores::GetScriptVersion());
MB_LogVersion(ST::GetScriptName()          , ST::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName() , SpawnScreen::GetScriptVersion());
MB_LogVersion(Manialink::GetScriptName()   , Manialink::GetScriptVersion());
MB_LogVersion(ITree::GetScriptName()       , ITree::GetScriptVersion());
***

***InitServer***
***
UIManager.UILayerDestroyAll();
SM::SetupDefaultVisibility();
UIManager.UIAll.AltMenuNoCustomScores  = True;
UIManager.UIAll.AltMenuNoDefaultScores = True;
UIManager.UIAll.OverlayHide321Go       = True;
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
***

***StartServer***
***
Top::Load();
Top::SetTopWidth(65.);
declare Real TopXPosition = -62.5;
declare Real TopYPosition = 42.;
declare Real TopXOffset = 65.;
declare Integer PlayersNbPerTop = 14;
declare Text TopBGImg = "file://Media/Manialinks/Shootmania/Common/topsBg.dds";
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
Top::Create(C_TopHits, C_TitleTopHits, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopInfections, C_TitleTopInfections, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopSurivals, C_TitleTopSurvivals, PlayersNbPerTop, <TopXPosition, TopYPosition>);
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);

ST::Load();
ST::SetStyle("LibST_Base");
ST::SetStyle("LibST_SMBaseSolo");
ST::SetStyle("LibST_SMBasePoints");
ST::SetStyle("LibST_SMWithLegends");

ST::SetFormat(C_ST_Columns, C_ST_Rows);
ST::SetTextScale(C_ST_Scale);
ST::SetSize(C_ST_Size_Header, C_ST_Size_Contents, C_ST_Size_Footer);

//TODO: setup scripts for automatic update
ST::CreateCol(C_ST_Col_Id_Status       , C_ST_Col_Legend_Status       , C_ST_Col_DefVal_Status       , C_ST_Col_Width_Status       , C_ST_Col_Weight_Status);
ST::CreateCol(C_ST_Col_Id_SurvivalTime , C_ST_Col_Legend_SurvivalTime , C_ST_Col_DefVal_SurvivalTime , C_ST_Col_Width_SurvivalTime , C_ST_Col_Weight_SurvivalTime);
ST::CreateCol(C_ST_Col_Id_Infections   , C_ST_Col_Legend_Infections   , C_ST_Col_DefVal_Infections   , C_ST_Col_Width_Infections   , C_ST_Col_Weight_Infections);
ST::CreateCol(C_ST_Col_Id_Hits         , C_ST_Col_Legend_Hits         , C_ST_Col_DefVal_Hits         , C_ST_Col_Width_Hits         , C_ST_Col_Weight_Hits);
ST::CreateCol(C_ST_Col_Id_Survivals    , C_ST_Col_Legend_Survivals    , C_ST_Col_DefVal_Survivals    , C_ST_Col_Width_Survivals    , C_ST_Col_Weight_Survivals);

ST::SetColTextAlign(C_ST_Col_Id_Status       , C_ST_Col_Align_Status);
ST::SetColTextAlign(C_ST_Col_Id_SurvivalTime , C_ST_Col_Align_SurvivalTime);
ST::SetColTextAlign(C_ST_Col_Id_Infections   , C_ST_Col_Align_Infections);
ST::SetColTextAlign(C_ST_Col_Id_Hits         , C_ST_Col_Align_Hits);
ST::SetColTextAlign(C_ST_Col_Id_Survivals    , C_ST_Col_Align_Survivals);

ST::GetLayer().Type = CUILayer::EUILayerType::Normal;

ST::Build("SM");

ITree::Load();

Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer([
    "TopTab"     => "Buddies",
    "ScoresTab"  => "Rankings",
    "InfTreeTab" => "Statistics"
], 30, -5, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);

Layers::Create(C_MainManialinkLayer, GenerateManialink());
Layers::Attach(C_MainManialinkLayer);
***

***StartMap***
***
// Required for manialink clan colors
Teams[C_SurvivorTeamId].ColorPrimary = C_SurvivorColor;
Teams[C_InfectedTeamId].ColorPrimary = C_InfectedColor;

UIManager.UIAll.MarkersXML = "";

G_InfectedPlayerCount = 0;
G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
G_AllSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();

G_MapSetting_WaterHasEffects              = False;

G_MapSetting_WaterForSurvivors_Eliminates = False;
G_MapSetting_WaterForSurvivors_Protects   = False;
G_MapSetting_WaterForSurvivors_Infects    = False;
G_MapSetting_WaterForSurvivors_Heals      = False;

G_MapSetting_WaterForInfected_Eliminates  = False;
G_MapSetting_WaterForInfected_Protects    = False;
G_MapSetting_WaterForInfected_Heals       = False;

foreach(Landmark in MapLandmarks) {
    declare Tags = TL::Split("_", Landmark.Tag);
    switch(Tags[0]) {
        case "Spawn":
        {
            SetupCustomSpawn(Landmark);
        }
        case "Tornado":
        {
            if(Tags.count == 2) {
                OffZoneCenterLandmarkId = Landmark.Id;
                OffZoneRadius = TL::ToReal(Tags[1]);
            }
        }
        case "Gate":
        {
            if(SetupGateConditions(Landmark)) {
                declare Boolean UpdateAlways for Landmark = False;
                if(UpdateAlways)
                    G_CondGates_Up_Always.add(Landmark);
                else
                    G_CondGates_Up_EachRound.add(Landmark);
                SetupConditionalGate(Landmark);
            }
        }
        case "Settings":
        {
            if(Tags.count > 1) {
                SetupMapSettings(Tags[1]);
            }
        }
    }
}

declare ModeName = "Infection";
SpawnScreen::SetModeName(ModeName);
SpawnScreen::AddSubsection("Rules", C_TxtRules, 0.);
SpawnScreen::AddSubsection("Round end", C_TxtRoundEnd, 30.);

declare Text MatchEnd;
MatchEnd ^= "A match ends after ";
if(S_RoundLimit > 0 && S_ScoreLimit == 0) {
    MatchEnd ^= S_RoundLimit ^ " round(s).";
} else if(S_RoundLimit == 0 && S_ScoreLimit > 0) {
    MatchEnd ^= "some player gets at least " ^ S_ScoreLimit ^ " point(s).";
} else {
    MatchEnd ^= S_RoundLimit ^ ", or after some player gets at least " ^ S_ScoreLimit ^ " point(s).";
}
SpawnScreen::AddSubsection("Match end", MatchEnd, 55.);

declare Text Description;
Description ^= "- $" ^ TL::ColorToText(C_SurvivorColor) ^ "Survivors$z VS $" ^ TL::ColorToText(C_InfectedColor) ^ "Infected$z;";
if(S_RewardFirstInfected > 0.0) {
    Description ^= "\n- the first infected gets " ^ S_RewardFirstInfected ^ "*(number of players - 1) additional points if all players are infected;";
}
if(S_InfectedShoot > 0) {
    if(S_InfectedShoot == 1) {
        Description ^= "\n- the first infected can shoot until there is a second infected;";
    } else {
        Description ^= "\n- the first " ^ S_InfectedShoot ^ " infected players can shoot until there is " ^ (S_InfectedShoot+1) ^ " infected players;";
    }
}
if(S_InfectionArmorBonus > 0) {
    Description ^= "\n- when an infected players infects another player he regenerates " ^ S_InfectionArmorBonus ^ " armor(s);";
}
SpawnScreen::AddSubsection("Description", Description, 80.);

SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores();
SpawnScreen::CreatePrettyRules(ModeName);
***

***InitSubmatch***
***
Scores::MatchBegin();
Top::ResetAll();
ST::ClearScores();
ITree::Clear();

foreach(Player in Players) {
    declare Integer Match_Infections for Player;
    declare Integer Match_Hits       for Player;
    declare Integer Match_Survivals  for Player;

    Match_Infections = 0;
    Match_Hits       = 0;
    Match_Survivals  = 0;
}

G_RestartingMatch = False;
***

***InitRound***
***
G_PrevPlayerProcTime = -1;
G_InfectionStarted   = False;

UseClans       = S_UseClans;
UseForcedClans = S_UseClans;

UseSameWallJump  = S_UseSameWallJump;
UsePvPWeapons    = !S_PursuitMode;
UsePvPCollisions = S_UsePVPCollisions;

MB_UseSectionRound = True;
***


***StartRound***
***
Scores::RoundBegin();

UIManager.UIAll.UISequence      = CUIConfig::EUISequence::Playing;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Default;

Message::SetDefaultAllMessages("");
Message::CleanAllMessages();

G_FirstInfectedId     = NullId;
G_InfectedPlayerCount = 0;

InitializePlayers();

StartTime = Now + 1000;
if(IsOperating()) {
    EndTime = Now + 1000 + S_PreparationTime;

    // Update conditional gates (allow opening)
    foreach(Gate in G_CondGates_Up_EachRound) {
        UpdateGateStatus(Gate, True);
    }
    foreach(Gate in G_CondGates_Up_Always) {
        UpdateGateStatus(Gate, True);
    }
} else {
    EndTime = -1;

    if(Players.count < C_MinimalPlayerCount) {
        Message::SetDefaultBigMessage(C_TxtWaitingPlayers);
        Message::SetDefaultStatusMessage(
            TL::Compose(C_TxtAtLeastNPlayersNeeded, TL::ToText(C_MinimalPlayerCount))
        );
    }

    // Open all gates
    foreach(Gate in G_CondGates_Up_EachRound) {
        SetGateOpened(Gate, True);
    }
    foreach(Gate in G_CondGates_Up_Always) {
        SetGateOpened(Gate, True);
    }
}

// Clear infection tree
ITree::Clear();
***


***InitTurn***
***
MB_UseSectionTurn = False;
***

***OnNewPlayer***
***
if(!IsInfected(Player)) {
    // If should be infected
    if(G_InfectionStarted && S_InfectNewPlayers) {
        Infect(Player);
    }
}

UpdateTable(Player);

declare UI <=> UIManager.GetUI(Player);
Tabs::UseTabs(UI, "ScoresTab");

***

***OnNewSpectator***
***
UpdateTable(Spectator);

declare UI <=> UIManager.GetUI(Spectator);
Tabs::UseTabs(UI, "ScoresTab");

if(UI != Null) {
    UI.SpectatorForcedClan      = 0;
    UI.SpectatorForceCameraType = 15;
}

***

***Yield***
***
Message::Loop();
Tabs::XmlRpcLoop();
***

***PlayLoop***
***
if(G_PrevPlayerProcTime + C_InfectionTick < Now) {
    G_PrevPlayerProcTime = Now;

    if(IsOperating())
        OperativePlayLoop();
    else
        NonoperationalPlayLoop();

    Top::Loop();
    ITree::Loop();
}

if(EndTime > -1 && EndTime <= Now) {
    if(!G_InfectionStarted && IsOperating()) {
        // Begin infection round
        G_InfectionStarted = True;

        if(S_TimeLimit > 0) {
            EndTime = Now + S_TimeLimit;
        } else {
            EndTime = -1;
        }

        declare FirstInfected = GetFirstInfected();
        if(FirstInfected != Null) {
            if(!IsInfected(FirstInfected)) {
                Infect(FirstInfected);
            }

            Message::SendStatusMessage("$iLet the infection begin...", 4000, 1);
            Message::SendBigMessage(FirstInfected, "$360First Infected!", 4000, 1);
            foreach(Survivor in AllPlayers) {
                if(IsInfected(Survivor))
                    continue;

                Message::SendBigMessage(Survivor, FirstInfected.Name ^ "$z$s$360 is the first infected!", 4000, 1);
            }
        } else {
            // This must not happen
            log(TL::Compose(C_UnexpectedBehaviour, "Choosing first infected", "Null"));
            MB_StopRound();
        }
    } else {
        // End infection round
        MB_StopRound();
    }
}

foreach(Event in PendingEvents) {
    switch(Event.Type) {
        case CSmModeEvent::EType::OnHit:
        {
            if(Event.Shooter == Event.Victim
            || IsProtectedByMap(Event.Victim)
            || !IsOperating()
            ) {
                Discard(Event);
                continue;
            }
            declare ShooterInfected = IsInfected(Event.Shooter);
            declare VictimInfected  = IsInfected(Event.Victim);
            if(VictimInfected && !ShooterInfected) {
                // OnSurvivorHitInfected
                if(S_HitInfectedScore != 0) {
                    OnHit(Event, S_HitInfectedScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && !ShooterInfected) {
                // OnSurvivorHitSurvivor
                if(S_PVP && S_HitSurvivorScore != 0) {
                    OnHit(Event, S_HitSurvivorScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && ShooterInfected) {
                // OnInfectedHitSurvivor
                Infect(Event.Victim, Event.Shooter);
                Discard(Event);
            } else {
                // OnInfectedHitInfected
                Discard(Event);
            }
        }
        case CSmModeEvent::EType::OnCommand:
        {
            switch(Event.CommandName) {
                case "Command_SetWarmup": SetWarmup(Event.CommandValueText);
            }
        }
        default:
            PassOn(Event);
    }
}

// Should be in `***Yield***`, but it depends on InfectByLogin
InfectionXmlRpcLoop();

declare netwrite Integer Net_PlayerCount   for Teams[0];
declare netwrite Integer Net_InfectedCount for Teams[0];

declare Integer Prev_PlayerCount         for This = -1;
declare Integer Prev_InfectedPlayerCount for This = -1;

declare Boolean PlayerCountChanged = False;

// The most reliable way of checking of player count changes.
// It's done in one place, so updated only once per playloop iteration.
if(Prev_PlayerCount != Players.count) {
    PlayerCountChanged = True;

    if(Prev_PlayerCount < C_MinimalPlayerCount && Players.count >= C_MinimalPlayerCount) {
        // If it's enough players now, restart round!
        MB_StopRound();
    } else if(Prev_PlayerCount >= C_MinimalPlayerCount && Players.count < C_MinimalPlayerCount) {
        // If it's not enough players now, restart round and display message!
        MB_StopRound();
    }

    Prev_PlayerCount = Players.count;
    Net_PlayerCount  = Prev_PlayerCount;

    // Infected player count might be changed too
    G_InfectedPlayerCount = CountInfected();

    UpdateTablePlayers();
}
if(Prev_InfectedPlayerCount != G_InfectedPlayerCount) {
    PlayerCountChanged = True;

    // If previously infected could shoot and now they cannot shoot, or
    // infected couldn't shoot previously and now they can shoot
    if((Prev_InfectedPlayerCount <= S_InfectedShoot && G_InfectedPlayerCount >  S_InfectedShoot) ||
        Prev_InfectedPlayerCount >  S_InfectedShoot && G_InfectedPlayerCount <= S_InfectedShoot)
    {
        // Re-setup infector weapons
        foreach(Infected in Players) {
            if(!IsInfected(Infected)) {
                continue;
            }
            SetupInfectedWeapons(Infected);
        }
    }

    // If someone got infected before first infected
    // and S_ForceFirstInfected is False, then remember the first infected
    // and force the infection begin
    if(!G_InfectionStarted && G_FirstInfectedId == NullId && !S_ForceFirstInfected && G_InfectedPlayerCount > 0) {
        // Get (un)lucky first infected
        declare Integer firstInfectionTime = C_MaxSignedInteger;
        foreach(Infected in Players) {
            if(!IsInfected(Infected)) {
                continue;
            }
            declare Integer InfectionTime for Infected = Now;
            if(firstInfectionTime > InfectionTime) {
                firstInfectionTime = InfectionTime;
                G_FirstInfectedId = Infected.Id;
            }
        }
        // If the unlucky first infected was found,
        // force infection begin
        if(G_FirstInfectedId != NullId && Players.existskey(G_FirstInfectedId)) {
            EndTime = Now;
        }
    }

    Prev_InfectedPlayerCount = G_InfectedPlayerCount;
    Net_InfectedCount        = G_InfectedPlayerCount;
}
if(PlayerCountChanged) {
    // If player count (survivor or infected) changed, update conditional gates
    PlayerCountChanged = False;
    foreach(Gate in G_CondGates_Up_Always) {
        // Permit only opening gates during the round
        UpdateGateStatus(Gate, False);
    }
    UpdateModeStatusMessage();
}

if((G_InfectionStarted && G_InfectedPlayerCount == 0) || (G_InfectedPlayerCount >= Players.count)) {
    // Don't end the round if not enough players
    if(Players.count >= C_MinimalPlayerCount) {
        MB_StopRound();
    }
}

***

***EndRound***
***

SM::UnspawnAllPlayers();
DestroyAllBotPlayers();

if(G_IsWarmup) {
    log(TL::Compose(C_UnexpectedBehaviour, "EndRound, when G_IsWarmup == True"));
}

StartTime = -1;
EndTime   = -1;

if(!G_RestartingMatch) {
    if(S_RewardFirstInfected > 0.0 && Players.existskey(G_FirstInfectedId)) {
        declare FirstInfected <=> Players[G_FirstInfectedId];
        Scores::AddPoints(FirstInfected, ML::NearestInteger(G_InfectedPlayerCount * S_RewardFirstInfected));
    }

    Scores::RoundEnd();
    Top::Loop();
    ITree::Loop();

    // Clean UI
    Message::SetDefaultAllMessages("");
    Message::CleanAllMessages();

    // Display result
    UIManager.UIAll.UISequence           = CUIConfig::EUISequence::EndRound;
    UIManager.UIAll.BigMessageSound      = CUIConfig::EUISound::EndRound;
    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

    declare Text BigMessage    = "";
    declare Text StatusMessage = "";
    if(G_InfectedPlayerCount >= Players.count) {
        BigMessage = C_TxtAllPlayersInfected;
    } else if(G_InfectedPlayerCount == 0) {
        BigMessage = C_TxtNoMoreInfected;
        MB_SectionRoundNb -= 1;
    } else {
        BigMessage    = C_TxtTimeLimitReached;
        StatusMessage = TL::Compose(C_TxtNPlayersSurvivied, TL::ToText(Players.count - G_InfectedPlayerCount));
    }
    UIManager.UIAll.BigMessage    = BigMessage;
    UIManager.UIAll.StatusMessage = StatusMessage;

    // Check for limits
    if(S_RoundLimit > 0 && MB_SectionRoundNb >= S_RoundLimit) {
        MB_StopMap();
    } else if(S_ScoreLimit > 0) {
        foreach(Player in Players) {
            if(Player.Score != Null && Player.Score.Points >= S_ScoreLimit) {
                MB_StopMap();
                break;
            }
        }
    }

    MB_Sleep(C_RoundPauseTime);

    UIManager.UIAll.BigMessageSound      = CUIConfig::EUISound::Silence;
    UIManager.UIAll.BigMessage           = "";
    UIManager.UIAll.StatusMessage        = "";
    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}

***

***EndMap***
***
Scores::MatchEnd();

UIManager.UIAll.BigMessage    = "";
UIManager.UIAll.StatusMessage = "";

declare CSmPlayer[] MaxScores;
declare Integer MaxScore = 0;
foreach(Player in Players) {
    if(Player.Score != Null) {
        if(MaxScore < Player.Score.Points) {
            MaxScores.clear();
            MaxScores.add(Player);
            MaxScore = Player.Score.Points;
        } else if (MaxScore == Player.Score.Points) {
            MaxScores.add(Player);
        }
    }
}

Layers::Detach(C_MainManialinkLayer);
Layers::Destroy(C_MainManialinkLayer);

if(MaxScore == 0) {
    UIManager.UIAll.BigMessage = _("|Match|Draw");
} else if(MaxScores.count > 0) {
    declare Text PlayerNames = MaxScores[0].Name;
    for(I, 1, MaxScores.count - 1) {
        if(I < MaxScores.count - 1) {
            PlayerNames ^= ", " ^ MaxScores[I].Name;
        } else {
            if(MaxScores.count > 2)
                PlayerNames ^= ",";
            PlayerNames ^= " and " ^ MaxScores[I].Name;
        }
    }

    if(MaxScores.count > 1) {
        UIManager.UIAll.BigMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    } else {
        UIManager.UIAll.StatusMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    }
}

UIManager.UIAll.UISequence              = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound         = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence              = CUIConfig::EUISequence::Podium;

MB_Sleep(C_MatchPauseTime);

UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage              = "";
UIManager.UIAll.StatusMessage           = "";

G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
G_AllSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();
***

***EndServer***
***
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
UIManager.ResetAll();
UIManager.UILayerDestroyAll();

ST::Unload();
***

// IsOperating returns whether the Script can operate in a normal mode
Boolean IsOperating() {
    return !G_IsWarmup && Players.count >= C_MinimalPlayerCount;
}

Boolean IsInfected(CSmPlayer _Player) {
    if(_Player != Null) {
        declare Boolean Infected for _Player = False;
        return Infected;
    }
    return False;
}

Integer CountInfected() {
    declare Integer Count = 0;
    foreach(Player in Players) {
        if(IsInfected(Player))
            Count += 1;
    }
    return Count;
}

Void OnPlayerCountChanged() {

}

Real ML__FMod(Real _Value, Real _Mod) {
    return _Value - ML::ToReal(ML::FloorInteger(_Value / _Mod)) * _Mod;
}

Real RealRandom(Real _Max) {
    declare Real Rand = ML::Rand(0.0, _Max);
    foreach(Player in Players) {
        Rand = ML__FMod(Rand + Player.Position.X +
                               Player.Position.Y +
                               Player.Position.Z, _Max);
    }
    return Rand;
}

Real SigmoidProbability(Real _X, Real _Max) {
    //https://www.wolframalpha.com/input/?i=plot+y+%3D+(100+-+100%2F(1+%2B+(x%2F(100*2%2F3))%5E6)%5E2)%2F100,+x%3D0..100
    if(_Max <= 0.000001) {
        return 1.0;
    }
    return 1 - 1 / (
                    ML::Pow(1 + ML::Pow(_X / (_Max * 2 / 3), 6.0), 2.0)
                   );
}

CSmPlayer GetFirstInfected() {
    if(G_FirstInfectedId != NullId) {
        if(Players.existskey(G_FirstInfectedId)) {
            return Players[G_FirstInfectedId];
        }
        G_FirstInfectedId = NullId;
    }

    declare Integer IMaxPoints = -1;
    declare Real    RMaxPoints = -1.0;
    declare Real    SumProb    = 0.0;
    declare Real    RandomNum;

    // Find Max Score
    foreach(Player in Players) {
        if(Player.Score != Null) {
            if(IMaxPoints < Player.Score.Points)
                IMaxPoints = Player.Score.Points;
        }
    }
    RMaxPoints = ML::ToReal(IMaxPoints);

    // Calculate probabilities of being chosen
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player;
        declare Real Points = 0.0;
        if(Player.Score != Null)
            Points = ML::ToReal(Player.Score.Points);
        ProbFirstInf = SigmoidProbability(Points, RMaxPoints);
        SumProb += ProbFirstInf;
    }

    RandomNum = RealRandom(SumProb);
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player = 0.0;
        RandomNum -= ProbFirstInf;
        if(RandomNum <= 0.0) {
            G_FirstInfectedId = Player.Id;
            return Player;
        }
    }

    // This must not happen
    log(TL::Compose(C_UnexpectedBehaviour, "GetFirstInfected", "" ^ RandomNum));
    if(Players.count > 0) {
        G_FirstInfectedId = Players[0].Id;
        return Players[0];
    }

    G_FirstInfectedId = NullId;
    return Null;
}

Void SetupArmor(CSmPlayer _Player, Integer _Max, Integer _Current) {
    if(_Max > 0) {
        _Player.ArmorMax = _Max * C_ArmorUnit;
    }
    if(_Current > 0) {
        _Player.Armor = _Current * C_ArmorUnit;
    }
    if(_Player.Armor > _Player.ArmorMax) {
        _Player.Armor = _Player.ArmorMax;
    }
}

Void SetupStamina(CSmPlayer _Player, Real _Gain, Real _Max) {
    if(_Gain > C_StaminaMaxGain) {
        _Player.StaminaMax = C_StaminaRealUnit;
    } else {
        _Player.StaminaMax = ML::Clamp(_Max, 0.1, 3.0);
    }
    _Player.StaminaGain = ML::Clamp(_Gain, C_StaminaMinGain, C_StaminaMaxGain);

}

Void InitSurvivor(CSmPlayer _Player) {
    _Player.ForceColor    = C_SurvivorColor;
    _Player.HasShield     = C_SurvivorHasShield;
    _Player.IsHighlighted = C_SurvivorIsHighlighted;
    _Player.EnergyLevel   = C_SurvivorEnergyLevel;

    SetupArmor(_Player, S_SurvivorMaxArmor, S_SurvivorRespawnArmor);
    SetupStamina(_Player, S_SurvivorStaminaGain, S_SurvivorStamina);

    ST::SetPlayerColor(_Player, C_ST_Color_Survivor);
}

Void InitInfected(CSmPlayer _Player) {
    _Player.ForceColor    = C_InfectedColor;
    _Player.HasShield     = C_InfectedHasShield;
    _Player.IsHighlighted = C_InfectedIsHighlighted;
    _Player.EnergyLevel   = C_InfectedEnergyLevel;

    SetupArmor(_Player, S_InfectedMaxArmor, S_InfectedRespawnArmor);
    SetupStamina(_Player, S_InfectedStaminaGain, S_InfectedStamina);

    ST::SetPlayerColor(_Player, C_ST_Color_Infected);
}

Void ForceSetWeapon(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    declare Weapon = CSmMode::EWeapon::Rocket;

    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        SetPlayerAmmo(_Player, Weapon, GetPlayerAmmoMax(_Player, Weapon));
    }
    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
        SetPlayerWeapon(_Player, Weapon, True);
    }
}

Void SetupSurvivorWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    _Player.AmmoGain = S_SurvivorAmmoGain;
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_SurvivorLaserMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_SurvivorRocketMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_SurvivorNucleusMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_SurvivorArrowMax);

    ForceSetWeapon(_Player);
}

Void SetupInfectedWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    if(!S_PursuitMode && G_InfectedPlayerCount > S_InfectedShoot) {
        _Player.AmmoGain = 0.0;
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   0);
    } else {
        _Player.AmmoGain = S_InfectedAmmoGain;
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_InfectedLaserMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_InfectedRocketMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_InfectedNucleusMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_InfectedArrowMax);
    }

    ForceSetWeapon(_Player);
}

Void UpdateTablePlayers() {
    declare Text[] Logins = Text[];
    foreach(Player in Players) {
        if(Player.Score == Null)
            continue;
        Logins.add(Player.Login);
    }
    foreach(Player in Spectators) {
        if(Player.Score == Null)
            continue;
        Logins.add(Player.Login);
    }
    ST::FilterLogins(Logins);
}

Void UpdateTablePlayerStatus(CSmPlayer _Player) {
    if(!Spectators.existskey(_Player.Id)) {
        if(IsInfected(_Player)) {
            declare Ident InfectorId for _Player;
            ST::SetColValue(C_ST_Col_Id_Status, _Player.Score, C_TxtInfected);
        } else {
            ST::SetColValue(C_ST_Col_Id_Status, _Player.Score, C_TxtSurvivor);
        }
    } else {
        ST::SetColValue(C_ST_Col_Id_Status, _Player.Score, C_TxtSpectator);
    }
}

Void UpdateTableSurvivalTime(CSmPlayer _Player) {
    declare Integer SpawnTime     for _Player = -1;
    declare Integer InfectionTime for _Player = -1;
    if(IsInfected(_Player)) {
        declare SurvivalTime = InfectionTime - SpawnTime;
        if(SurvivalTime < 0) {
            SurvivalTime = 0;
        }
        ST::SetColValue(C_ST_Col_Id_SurvivalTime, _Player.Score, TL::TimeToText(SurvivalTime, True));
    } else {
        ST::SetColValue(C_ST_Col_Id_SurvivalTime, _Player.Score, C_TxtUnkTime);
    }
}

Void UpdateTableInfections(CSmPlayer _Player) {
    declare Round_Infections for _Player = 0;
    ST::SetColValue(C_ST_Col_Id_Infections, _Player.Score, "$080" ^ Round_Infections);
}

Void UpdateTableHits(CSmPlayer _Player) {
    declare Round_Hits for _Player = 0;
    ST::SetColValue(C_ST_Col_Id_Hits, _Player.Score, "$f00" ^ Round_Hits);
}

Void UpdateTableSurvivals(CSmPlayer _Player) {
    declare Round_Survivals for _Player = 0;
    ST::SetColValue(C_ST_Col_Id_Survivals, _Player.Score, "$ff0" ^ Round_Survivals);
}

Void UpdateTable(CSmPlayer _Player) {
    UpdateTablePlayerStatus(_Player);
    UpdateTableSurvivalTime(_Player);
    UpdateTableInfections(_Player);
    UpdateTableHits(_Player);
    UpdateTableSurvivals(_Player);
    if(IsInfected(_Player)) {
        ST::SetPlayerColor(_Player, C_ST_Color_Infected);
    } else {
        ST::SetPlayerColor(_Player, C_ST_Color_Survivor);
    }
}

Void UpdateModeStatusMessage() {
    ModeStatusMessage = TL::Compose(
        """Currently on the server:
-   $080%1$g infected,
-   $f00%2$g survivors, and
-   $aaa%3$g spectators.
    """,
        TL::ToText(G_InfectedPlayerCount),
        TL::ToText(Players.count - G_InfectedPlayerCount),
        TL::ToText(Spectators.count)
    );
}

Void RewardInfector(CSmPlayer _Infector, Real _Score) {
    if(_Score < 1.0)
        return;
    declare Ident InfectorId for _Infector;
    if(InfectorId != NullId && Players.existskey(InfectorId)) {
        declare _Parent = Players[InfectorId];
        Scores::AddPoints(_Parent, ML::NearestInteger(_Score));
        RewardInfector(_Parent, _Score * S_RewardInfectors);
    }
}

Void RewardSurvivorsForSurvivingInfection() {
    foreach(Survivor in Players) {
        if(IsInfected(Survivor))
            continue;

        declare Round_Survivals for Survivor = 0;
        declare Match_Survivals for Survivor = 0;
        Round_Survivals += 1;
        Match_Survivals += 1;
        Top::SetRecord(Survivor, C_TopSurivals, TL::ToText(Match_Survivals), -Match_Survivals);
        Scores::AddPoints(Survivor, S_ScoreForSurv1Inf);
        UpdateTableSurvivals(Survivor);
    }
}

Boolean IsProtectedByMap(CSmPlayer _Player) {
    if(_Player == Null)
        return False;

    if(_Player.IsInWater) {
        if(IsInfected(_Player)) {
            return G_MapSetting_WaterForInfected_Protects;
        } else {
            return G_MapSetting_WaterForSurvivors_Protects;
        }
    }

    return False;
}

Void OnHit(CSmModeEvent _Event, Integer _Multiplier) {
    declare Match_Hits for _Event.Shooter = 0;
    declare Round_Hits for _Event.Shooter = 0;
    declare Integer Points = _Event.Damage / C_ArmorUnit * _Multiplier;
    Round_Hits += Points;
    Match_Hits += Points;
    Scores::AddPoints(_Event.Shooter, Points);
    Top::SetRecord(_Event.Shooter, C_TopHits, TL::ToText(Match_Hits), -Match_Hits);
    UpdateTableHits(_Event.Shooter);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector, Text _CauseFmt) {
    if(_Victim == Null)
        return;

    if(IsInfected(_Victim) || (_Infector != Null && !IsInfected(_Infector))) {
        log("ERROR: Infect is called with already infected victim, or not infected infector!");
        return;
    }

    declare netwrite Boolean Net_Infected     for _Victim;
    declare netwrite Real Net_NearestSurvivor for _Victim;

    declare Ident InfectorId  for _Victim;
    declare Boolean Infected  for _Victim = S_InfectNewPlayers;

    declare Integer SpawnTime     for _Victim;
    declare Integer InfectionTime for _Victim;

    declare Text InfectorLogin = "";

    Infected            = True;
    Net_Infected        = True;
    Net_NearestSurvivor = 0.0;
    if(_Infector != Null) {
        InfectorId = _Infector.Id;

        declare Match_Infections for _Infector = 0;
        declare Round_Infections for _Infector = 0;
        Round_Infections += 1;
        Match_Infections += 1;
        Top::SetRecord(_Infector, C_TopInfections, TL::ToText(Match_Infections), -Match_Infections);

        if(_Infector.Armor < _Infector.ArmorMax) {
            _Infector.Armor += S_InfectionArmorBonus * C_ArmorUnit;
        }
        if(S_RewardInfectors > 0) {
            RewardInfector(_Infector, S_InfectionScore * S_RewardInfectors);
        }

        Scores::AddPoints(_Infector, S_InfectionScore);
        UpdateTableInfections(_Infector);

        // Notify everyone about infection
        //Message::SendStatusMessage(TL::Compose("%1$z$s infected %2$z$s!", _Infector.Name, _Victim.Name), 4000, 1);
        //Message::SendBigMessage(_Victim, "$360Infected!", 4000, 1);

        InfectorLogin = _Infector.Login;
    }

    G_InfectedPlayerCount += 1;

    if(_Victim.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        if(S_RespawnOnInfection) {
            UnspawnPlayer(_Victim);
        } else {
            InitInfected(_Victim);
            SetupInfectedWeapons(_Victim);
        }
    }

    InfectionTime = Now;
    UpdateTablePlayerStatus(_Victim);
    UpdateTableSurvivalTime(_Victim);

    RewardSurvivorsForSurvivingInfection();

    // SendNotice to all players about infection,
    // and update infection graph
    if(_Infector != Null) {
        foreach(Player in AllPlayers) {
            declare Text Message;
            if(Player == _Infector) {
                Message = TL::Compose(C_TxtYouInfectedA, _Victim.Name);
            } else if (Player == _Victim) {
                Message = TL::Compose(C_TxtAInfectedYou, _Infector.Name);
            } else {
                Message = TL::Compose(C_TxtAInfectedB, _Infector.Name, _Victim.Name);
            }
            UIManager.GetUI(Player).SendNotice(
                Message,
                CUIConfig::ENoticeLevel::PlayerInfo,
                _Infector.User,
                CUIConfig::EAvatarVariant::Default,
                CUIConfig::EUISound::PlayerHit,
                0
            );
        }

        // Update infection graph
        ITree::Infect(_Victim.Login, _Infector.Login);
    } else {
        if(_CauseFmt != "") {
            UIManager.UIAll.SendNotice(
                TL::Compose(_CauseFmt, _Victim.Name),
                CUIConfig::ENoticeLevel::PlayerInfo,
                _Victim.User,
                CUIConfig::EAvatarVariant::Default,
                CUIConfig::EUISound::PlayerHit,
                0
            );
        }

        // Update infection graph
        ITree::Infect(_Victim.Login);
    }

    if(G_InfectedPlayerCount == Players.count - 1) {
        // Get last survivor
        declare CSmPlayer LastSurvivor = Null;
        foreach(Player in Players) {
            if(!IsInfected(Player)) {
                LastSurvivor = Player;
                break;
            }
        }
        if(LastSurvivor != Null) {
            Message::SendBigMessage(
                TL::Compose(
                    "%1$z$s is the last survivor!",
                    LastSurvivor.Name
                ),
                C_LastSurvivorMsgDuration,
                C_LastSurvivorMsgPriority
            );
        }
    }

    XmlRpc.SendCallbackArray(C_Inf_XmlClb_Infected, [InfectorLogin, _Victim.Login]);
}

Void Infect(CSmPlayer _Victim, Text _CauseFmt) {
    Infect(_Victim, Null, _CauseFmt);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector) {
    Infect(_Victim, _Infector, "");
}

Void Infect(CSmPlayer _Victim) {
    Infect(_Victim, Null);
}

Void InfectByLogin(Text _Login) {
    foreach(Player in Players) {
        if(IsInfected(Player))
            continue;
        if(Player.Login == _Login) {
            Infect(Player);
            break;
        }
    }
}

Void EliminateByWater(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    UnspawnPlayer(_Player);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_TxtPlayerDrowned,
        CUIConfig::ENoticeLevel::PlayerInfo,
        _Player.User,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::PlayerHit,
        0
    );
}

Void ManageMapWaterEffectsForInfected(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForInfected_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Void ManageMapWaterEffectsForSurvivor(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForSurvivors_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForSurvivors_Infects) {
            if(!IsInfected(_Player)) {
                Infect(_Player, C_TxtPlayerInfectedByWater);
            }
        }
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Boolean InfectsByDistance(Vec3 _P1, Vec3 _P2) {
    if(S_SphericalInfectionDistance <= 0.0) {
        return ML::Abs(_P1.X - _P2.X) <= S_HorizontalInfectionDistance &&
            ML::Abs(_P1.Y - _P2.Y) <= S_VerticalInfectionDistance &&
            ML::Abs(_P1.Z - _P2.Z) <= S_HorizontalInfectionDistance;
    }
    return ML::Distance(_P1, _P2) <= S_SphericalInfectionDistance;
}

Void ManageInfectedPlayer(CSmPlayer _Infected) {
    declare netwrite Net_NearestSurvivor for _Infected = 0.0;
    declare MinDetectDist = S_SurvivorDetectorMaxDist;
    foreach(Survivor in Players) {
        if(Survivor.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
            continue;
        if(IsInfected(Survivor))
            continue;
        if(InfectsByDistance(Survivor.Position, _Infected.Position)) {
            if(!IsProtectedByMap(Survivor)) {
                Infect(Survivor, _Infected);
            }
        }
        declare Real Distance = ML::Distance(Survivor.Position, _Infected.Position);
        if(Distance < MinDetectDist) {
            MinDetectDist = Distance;
        }
    }
    Net_NearestSurvivor = 1.0 - MinDetectDist / S_SurvivorDetectorMaxDist;
}

//TODO: use Message:: here
Void ManageMapLeaver(CSmPlayer _Player) {
    if(S_CanLeaveMapFor < 0) {
        return;
    }
    declare Integer LeftMapSince for _Player = -1;
    declare PlayerUI <=> UIManager.GetUI(_Player);
    if(_Player.Position.X     < 0
    || _Player.Position.Z     < 0
    || _Player.Position.X / 8 > Map.Size.X
    || _Player.Position.Z / 8 > Map.Size.Z)
    {
        if(LeftMapSince == -1) {
            LeftMapSince = Now;
        }
        if(Now - LeftMapSince < S_CanLeaveMapFor) {
            PlayerUI.BigMessage    = C_TxtGetBackToBattleField;
            PlayerUI.StatusMessage = TL::Compose(C_TxtYouWillBeInfectedInX, TL::ToText(S_CanLeaveMapFor / 1000 - ML::FloorInteger((Now - LeftMapSince) / 1000.0)));
        } else {
            Infect(_Player, C_TxtPlayerWasEliminated);
        }
    } else if(LeftMapSince != -1) {
        LeftMapSince = -1;
        PlayerUI.BigMessage    = "";
        PlayerUI.StatusMessage = "";
    }
}

Void ManageIdlePlayer(CSmPlayer _Player) {
    if(S_ForceSpecAfter <= 0) {
        return;
    }

    if(_Player.IdleDuration < S_ForceSpecAfter) {
        return;
    }

    declare Integer SpawnTime for _Player = Now;
    if(Now - SpawnTime < S_CanIdleAfterSpawn) {
        return;
    }

    Users_RequestSwitchToSpectator(_Player.User);
    UIManager.UIAll.SendChat(_Player.Name ^ C_WasIdleTooLongMovingToSpec);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_PlayerIsIdle,
        CUIConfig::ENoticeLevel::PlayerInfo,
        Null,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::Silence,
        0
    );
}

Void ConditionError(Text _Error) {
    declare Text Message = C_Cond_TxtPrefix ^ "Error: " ^ _Error;
    log(Message);
    UIManager.UIAll.SendChat(Message);
}

Boolean SetupLandmarkConditions(CSmMapLandmark _Landmark, Text _TextConditions) {
    declare Integer[][] Conditions for _Landmark;

    declare Text[] Split;
    declare Text[] SplitOR;
    declare Text[] SplitAND;

    SplitOR = TL::Split("|", _TextConditions);
    foreach(ORConds in SplitOR) {
        SplitAND = TL::Split("&", ORConds);
        foreach(Cond in SplitAND) {
            declare Integer CCountSource = -1;
            declare Integer CComparison  = -1;
            declare Integer CValue       = -1;
            while(True) {
                Split = TL::Split("<", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_LT;
                    break;
                }
                Split = TL::Split("=", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_EQ;
                    break;
                }
                Split = TL::Split(">", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_GT;
                    break;
                }
                break;
            }
            if(CComparison == -1) {
                ConditionError("Invalid comparison `" ^ Cond ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            switch(Split[0]) {
                case C_Cond_TxtPlayers   : CCountSource = C_Cond_Players;
                case C_Cond_TxtSurvivors : CCountSource = C_Cond_Survivors;
                case C_Cond_TxtInfected  : CCountSource = C_Cond_Infected;
            }
            if(CCountSource == -1) {
                ConditionError("Invalid count source `" ^ Split[0] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            CValue = TL::ToInteger(Split[1]);
            if(CValue == -1) {
                ConditionError("Invalid value `" ^ Split[1] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            Conditions.add([CCountSource, CComparison, CValue, C_Cond_Chain_AND]);
        }
        if(Conditions.count > 0) {
            Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_OR;
        }
    }
    if(Conditions.count > 0) {
        Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_None;
    }

    return Conditions.count > 0;
}

Boolean SetupGateConditions(CSmMapLandmark _Gate) {
    declare Text[] Split;
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;
    declare Boolean UpdateAlways   for _Gate = False;

    Split = TL::Split("_", _Gate.Tag);
    if(Split.count != 2) {
        return False;
    }
    if(Split[0] != "Gate") {
        return False;
    }

    Split = TL::Split(":", Split[1]);
    if(Split.count != 3) {
        return False;
    }

    UpdateAlways  = Split[0] == "A";
    DefaultOpened = Split[1] == "O";

    return SetupLandmarkConditions(_Gate, Split[2]);
}

Void SetupConditionalGate(CSmMapLandmark _Gate) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    Gate.Automatic    = False;
    Gate.ManualClosed = True;
    Gate.Clan         = 0;
    Gauge.Clan        = 0;
    Gauge.Speed       = 0;
}

Void SetupCustomSpawn(CSmMapLandmark _Spawn) {
    declare Text[] Split;
    //declare Gauge <=> _Spawn.Gauge;

    Split = TL::Split("_", _Spawn.Tag);
    if(Split[0] != "Spawn") {
        return;
    }

    declare Boolean IsCommonSpawn = False;
    if(Split.count > 1) {
        Split = TL::Split(":", Split[1]);
        switch(Split[0]) {
            case C_Cond_TxtInfected:
            {
                G_InfectedSpawns.add(_Spawn);
                //Gauge.Clan = C_InfectedClanNum;
            }
            case C_Cond_TxtSurvivors:
            {
                G_SurvivorSpawns.add(_Spawn);
                //Gauge.Clan = C_SurvivorClanNum;
            }
            default: IsCommonSpawn = True;
        }
        if(Split.count > 1) {
            SetupLandmarkConditions(_Spawn, Split[1]);
        }
    } else {
        IsCommonSpawn = True;
    }
    if(IsCommonSpawn) {
        // Add to both lists, because it's common spawn
        G_InfectedSpawns.add(_Spawn);
        G_SurvivorSpawns.add(_Spawn);
        //Gauge.Clan = 0;
    }

    G_AllSpawns.add(_Spawn);
}

Void SetupMapWaterProperties(Text _TxtProperty) {
    declare Text[] Args = TL::Split("=", _TxtProperty);
    if(Args.count != 2)
        return;
    switch(Args[0]) {
        case C_Cond_TxtSurvivors:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForSurvivors_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForSurvivors_Protects   = True;
                case C_MapSetting_WaterProperty_TxtInfects    : G_MapSetting_WaterForSurvivors_Infects    = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForSurvivors_Heals      = True;
            }
        }
        case C_Cond_TxtInfected:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForInfected_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForInfected_Protects   = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForInfected_Heals      = True;
            }
        }
    }
    G_MapSetting_WaterHasEffects = True;
}

Void SetupMapSettings(Text _TxtSettings) {
    declare Text[] Settings = TL::Split(";", _TxtSettings);
    foreach(Setting in Settings) {
        declare Text[] Args = TL::Split(":", Setting);
        switch(Args[0]) {
            case C_MapSetting_Water: SetupMapWaterProperties(Args[1]);
        }
    }
}

Integer GetConditionalCount(Integer _Source) {
    switch(_Source) {
        case C_Cond_Players   : return Players.count;
        case C_Cond_Survivors : return Players.count - G_InfectedPlayerCount;
        case C_Cond_Infected  : return G_InfectedPlayerCount;
    }
    return 0;
}

Boolean Compare(Integer _Count, Integer _Comparison, Integer _Value) {
    switch(_Comparison) {
        case C_Cond_Comparison_LT : return _Count < _Value;
        case C_Cond_Comparison_EQ : return _Count == _Value;
        case C_Cond_Comparison_GT : return _Count > _Value;
    }
    return False;
}

Boolean ConditionsAreSatisfied(Integer[][] _Conditions) {
    declare Boolean Result = True;
    declare Integer PrevChain = C_Cond_Chain_None;
    foreach(Condition in _Conditions) {
        declare CurrentResult = Compare(
            GetConditionalCount(Condition[C_Cond_CountSource]),
            Condition[C_Cond_Comparison],
            Condition[C_Cond_Value]
        );
        switch(PrevChain) {
            case C_Cond_Chain_AND : Result = Result && CurrentResult;
            case C_Cond_Chain_OR  : Result = Result || CurrentResult;
            case C_Cond_Chain_None: Result = CurrentResult;
            default:
            {
                // This must not happen
                log(TL::Compose(C_UnexpectedBehaviour, "ConditionsAreSatisfied", "" ^ PrevChain));
                Result = False;
            }
        }
        PrevChain = Condition[C_Cond_Chain];
    }
    return Result;
}

Void SetGateOpened(CSmMapLandmark _Gate, Boolean _Opened) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    if(_Opened) {
        Gauge.ValueReal = 0.0;
    } else {
        Gauge.ValueReal = 1.0;
    }
    Gauge.Captured = !_Opened;
    Gate.ManualClosed = !_Opened;
}

Void UpdateGateStatus(CSmMapLandmark _Gate, Boolean _CanClose) {
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;

    if(!_CanClose && !_Gate.Gate.ManualClosed)
        return;

    declare Status = DefaultOpened;
    if(ConditionsAreSatisfied(Conditions)) {
        // Toggle `Status` if the conditions are satisfied
        Status = !Status;
    }

    SetGateOpened(_Gate, Status);
}

CSmMapLandmark[] GetPermittedSpawns(CSmMapLandmark[] _Spawns) {
    declare CSmMapLandmark[] PermittedSpawns;
    foreach(Spawn in _Spawns) {
        declare Integer[][] Conditions for Spawn;
        if(Conditions.count > 0) {
            if(!ConditionsAreSatisfied(Conditions))
                continue;
        }
        PermittedSpawns.add(Spawn);
    }
    return PermittedSpawns;
}

Void SpawnAndInitPlayer(CSmMapPlayerSpawn _Spawn, CSmPlayer _Player) {
    declare Boolean Infected  for _Player = False;
    declare Integer SpawnTime for _Player = -1;
    declare Integer ClanNum = 0;

    if(SpawnTime == -1) {
        SpawnTime = Now + S_RespawnDelay;
    }

    if(!Infected) {
        // Survivor
        InitSurvivor(_Player);
        if(S_UseClans) {
            ClanNum = C_SurvivorClanNum;
        }
    } else {
        // Infected
        InitInfected(_Player);
        if(S_UseClans) {
            ClanNum = C_InfectedClanNum;
        }
    }

    if(G_MapSetting_WaterForSurvivors_Heals || G_MapSetting_WaterForInfected_Heals) {
        // Reset ArmorReplenishGain if Player respawned in water,
        // otherwise player could get an additional armor because of
        // G_MapSetting_WaterFor..._Heals
        _Player.ArmorReplenishGain = 0;
    }

    SM::SpawnPlayer(_Player, ClanNum, _Player.Armor, _Spawn, SpawnTime);

    // Weapons setup
    // can be done only after spawn :(
    if(!Infected) {
        // Survivor
        SetupSurvivorWeapons(_Player);
    } else {
        // Infected
        SetupInfectedWeapons(_Player);
    }
}

Void SpawnAndInitPlayers(CSmPlayer[] _Players) {
    declare CSmMapLandmark[] SurvivorSpawns;
    declare CSmMapLandmark[] InfectedSpawns;
    if(IsOperating()) {
        SurvivorSpawns = GetPermittedSpawns(G_SurvivorSpawns);
        InfectedSpawns = GetPermittedSpawns(G_InfectedSpawns);
    }
    foreach(Player in _Players) {
        declare CSmMapLandmark[] Spawns;
        if(IsOperating()) {
            // New players are already infected if infection has started but have SpawnTime == -1
            // But existing players have SpawnTime != -1 if they respawn.
            declare Integer SpawnTime for Player;

            if(!IsInfected(Player) && SpawnTime != -1 && C_InfectOnRespawn) {
                if(G_InfectionStarted || S_InfectOnPreparationRespawn) {
                    Infect(Player);
                }
            }

            if(IsInfected(Player)) {
                Spawns = InfectedSpawns;
            } else {
                Spawns = SurvivorSpawns;
            }

        } else {
            Spawns = G_AllSpawns;
        }

        SpawnAndInitPlayer(
            Spawns[ML::Rand(0, Spawns.count - 1)].PlayerSpawn,
            Player
        );
    }
}

// Initializes all players, and un-infects them
Void InitializePlayers() {
    foreach(Player in AllPlayers) {
        declare netwrite Boolean Net_Infected     for Player;
        declare netwrite Real Net_NearestSurvivor for Player;

        declare Ident InfectorId      for Player;
        declare Boolean Infected      for Player;
        declare Integer SpawnTime     for Player;
        declare Integer InfectionTime for Player;

        declare Integer LeftMapSince for _Player;

        Net_Infected        = False;
        Net_NearestSurvivor = 0.0;

        InfectorId          = NullId;
        Infected            = False;
        SpawnTime           = -1;
        InfectionTime       = -1;

        LeftMapSince = -1;

        if(_Victim.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
            if(S_RespawnOnInfection) {
                UnspawnPlayer(Player);
            } else {
                InitSurvivor(_Victim);
                SetupSurvivorWeapons(_Victim);
            }
        }
    }
}

Void OperativePlayLoop() {
    declare CSmPlayer[] UnspawnedPlayers;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            UnspawnedPlayers.add(Player);
            continue;
        }
        if(Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
            continue;
        }

        if(IsInfected(Player)) {
            // Infected

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForInfected(Player);
            }

            // Provide infinite stamina for infected
            if(S_InfectedStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check for infection and nearest survivor
            ManageInfectedPlayer(Player);
        } else {
            // Survivor

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForSurvivor(Player);
            }

            // Provide infinite stamina for survivor
            if(S_SurvivorStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check if leaving the map, and take some actions
            ManageMapLeaver(Player);
        }
        ManageIdlePlayer(Player);
    }

    if(UnspawnedPlayers.count > 0)
        SpawnAndInitPlayers(UnspawnedPlayers);
}

Void NonoperationalPlayLoop() {
    declare CSmPlayer[] UnspawnedPlayers;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            UnspawnedPlayers.add(Player);
            continue;
        }
    }

    if(UnspawnedPlayers.count > 0)
        SpawnAndInitPlayers(UnspawnedPlayers);
}

Void SetWarmup(Text _Message) {
    if(_Message != "") {
        declare Messages = TL::Split(";", _Message);

        declare Text BigMessage    = "";
        declare Text StatusMessage = "";

        if(Messages.count > 0)
            BigMessage = Messages[0];
        if(Messages.count > 1)
            StatusMessage = Messages[1];

        Message::SetDefaultBigMessage(BigMessage);
        Message::SetDefaultStatusMessage(StatusMessage);

        if(G_IsWarmup)
            return;
        G_IsWarmup = True;

        EndTime = -1;

        InitializePlayers();

        // Open all gates
        foreach(Gate in G_CondGates_Up_EachRound) {
            SetGateOpened(Gate, True);
        }
        foreach(Gate in G_CondGates_Up_Always) {
            SetGateOpened(Gate, True);
        }
    } else {
        Message::SetDefaultBigMessage("");
        Message::SetDefaultStatusMessage("");

        if(!G_IsWarmup)
            return;
        G_IsWarmup = False;

        G_RestartingMatch = True;
        MB_StopSubmatch();
        MB_SectionSubmatchNb -= 1;
    }
}

Void InfectionXmlRpcLoop() {
    foreach(Event in XmlRpc.PendingEvents) {
        switch(Event.Type) {
            case CXmlRpcEvent::EType::Callback:
            {
                switch(Event.Param1) {
                    case C_Inf_XmlRpc_InfectByLogin:
                    {
                        InfectByLogin(Event.Param2);
                    }
                }
            }
        }
    }
}

Text GenerateManialink() {
    return """
        <frame posn="122 -72">
            <label style="TextRaceChrono" posn="0 0" valign="center" halign="right" textcolor="{{{TL::ColorToText(C_InfectedColor)}}}" text="{{{G_InfectedPlayerCount}}}" id="Infected"/>
            <label style="TextRaceChrono" posn="1 -3" valign="center" halign="center" textcolor="fff" text="/" />
            <label style="TextRaceChrono" posn="2 -6" valign="center" halign="left" textcolor="fff" text="{{{Players.count}}}" id="Players"/>
            <label posn="8 -7" valign="center" halign="left" textcolor="fff" text="infected" />
        </frame>

        <label style="TextTitle1" posn="0 20" halign="center" visible="false" textcolor="f00" id="Idle_Text">{{{C_IdlePlayerWarning}}}</label>
        <label style="TextRaceChrono" posn="0 15" halign="center" visible="false" id="Idle_Time" />

        <frame id="NearestSurvivorFrame">
            <frame>
                <gauge posn="-21 -87" ratio="0.5" clan="{{{C_InfectedClanNum}}}" sizen="53 8" rot="180" id="NearestSurvivor" />
                <quad posn="-27 -76 10" sizen="14 14" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" />
                <quad posn="-26 -77 11" sizen="12 12" image="file:///Media/Manialinks/ShootMania/Common/MainPlayer.dds" id="SurvivorImage" />
            </frame>
            <quad posn="-0.3 0.3 0" sizen="0.6 0.6" bgcolor="fff" />
        </frame>
        <script>
        <!--
        {{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
        {{{Manialink::Animations(["EaseInOutQuad"])}}}
        main() {
            wait(InputPlayer != Null);

            declare netread Net_InfectedCount   for Teams[0] = 0;
            declare netread Net_PlayerCount     for Teams[0] = 0;
            declare netread Net_Infected        for InputPlayer = False;
            declare netread Net_NearestSurvivor for InputPlayer = 0.0;

            declare Real NearestSurvivor = 0.0;
            declare Boolean IsSpawned = False;

            declare Label_Infected        = (Page.GetFirstChild("Infected")             as CMlLabel);
            declare Label_Players         = (Page.GetFirstChild("Players")              as CMlLabel);
            declare Label_Idle_Text       = (Page.GetFirstChild("Idle_Text")            as CMlLabel);
            declare Label_Idle_Time       = (Page.GetFirstChild("Idle_Time")            as CMlLabel);
            declare Frame_NearestSurvivor = (Page.GetFirstChild("NearestSurvivorFrame") as CMlFrame);

            while(True) {
                yield;

                IsSpawned = InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned;

                Label_Infected.Value = TL::ToText(Net_InfectedCount);
                Label_Players.Value  = TL::ToText(Net_PlayerCount);

                Frame_NearestSurvivor.Visible = Net_Infected && IsSpawned;
                if(Frame_NearestSurvivor.Visible) {
                    LibManialink_AnimLoop();
                    if(NearestSurvivor != Net_NearestSurvivor) {
                        NearestSurvivor = Net_NearestSurvivor;

                        declare Intensity = 0.5 + NearestSurvivor / 2.0;
                        LibManialink_Anim("<gauge id=\"NearestSurvivor\" ratio=\"" ^ ML::Clamp(NearestSurvivor, 0.0, 1.0) ^ "\" />", 200, "EaseInOutQuad");
                        LibManialink_Anim("<quad id=\"SurvivorImage\" colorize=\"" ^ TL::ColorToText(<0.0, Intensity, 0.0>) ^ "\" />", 200, "EaseInOutQuad");
                    }
                }

                if({{{S_ForceSpecAfter > 0}}}) {
                    if(IsSpawned && InputPlayer.IdleDuration >= {{{S_ForceSpecAfter * 0.8}}}) {
                        declare Integer TimeLeft = {{{S_ForceSpecAfter}}} - InputPlayer.IdleDuration;
                        Label_Idle_Text.Opacity  = 0.5 + 0.5 * ML::Sin(Now / (50.0 * ML::PI()));
                        Label_Idle_Text.Visible  = True;
                        if(TimeLeft >= 0) {
                            Label_Idle_Time.Value = TL::TimeToText(TimeLeft);
                        }
                        Label_Idle_Time.Visible = TimeLeft >= 0;
                    } else {
                        Label_Idle_Text.Visible = False;
                        Label_Idle_Time.Visible = False;
                    }
                }
            }
        }
        -->
        </script>""";
}

