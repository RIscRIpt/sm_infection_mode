/*
 * Infection game mode for ShootMania Storm
 * Copyright Â© 2017 RIscRIpt
 *
 * This script is highly modificated, and fully rewritten
 * version of the mewin's script which can be found
 * on his website: https://mewin.de/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License v3 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#Extends "Modes/ShootMania/Base/ModeShootmania.Script.txt"

#Const Version    "2018-01-20"
#Const ScriptName "Infection.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/RIscRIpt/InfectionTree.Script.txt" as ITree
#Include "Libs/RIscRIpt/InfectionScores.Script.txt" as IScores
#Include "Libs/domino54/Blacklist.Script.txt" as Blacklist

//#Setting S_IsChannelServer                  False       as "<hidden>" //set to True if channel server
#Setting S_Paused                           False       as "<hidden>" //as "enable pause"
#Setting S_PauseMessage                     ""          as "<hidden>" //as "pause message (bigmessage; statusmessage)"
#Setting S_PauseKeepResultsOnUnpause        True        as "<hidden>" //as "keep results on unpause"
#Setting S_HorizontalInfectionDistance      0.61        as "<hidden>" //as "horizontal infection distance"
#Setting S_VerticalInfectionDistance        2.16        as "<hidden>" //as "vertical infection distance"
#Setting S_SphericalInfectionDistance       -1.30384    as "<hidden>" //as "spherical infection distance"
#Setting S_InfectionScore                   4           as "infection score"
#Setting S_InfectionArmorBonus              1           as "armor bonus for infection"
#Setting S_PVP                              False       as "enable PvP for survivors"
#Setting S_PursuitMode                      False       as "pursuit mode (need round restart)"
#Setting S_UsePVPCollisions                 False       as "use PvP collisions (need round restart)"
#Setting S_UseClans                         True        as "use teams (need map restart)"
#Setting S_UseSameWallJump                  False       as "allow escalator jump (need round restart)"
#Setting S_RespawnOnInfection               True        as "respawn on infection (need `use teams` == False)"
#Setting S_SurvivorRespawnPunishment        0           as "survivor respawn punishment"
#Setting S_HitSurvivorScore                 0           as "hit survivor score (for PvP mode)"
#Setting S_HitInfectedScore                 1           as "hit infected score"
#Setting S_MaxDamage                        100         as "max hit damage"
#Setting S_ScoreForSurv1Inf                 1           as "score for surviving single infection"
#Setting S_TimeLimit                        300000      as "time limit for a round"
#Setting S_ScoreLimit                       100         as "score limit for a match"
#Setting S_RoundLimit                       0           as "round limit for a match"
#Setting S_PreparationTime                  10000       as "time till first infection"
#Setting S_InfectNewPlayers                 True        as "<hidden>" //as "infect new players"
#Setting S_RewardInfectors                  0.5         as "<hidden>" //as "rewarding infected `parent` cooef."
#Setting S_RewardFirstInfected              0.5         as "<hidden>" //as ""
#Setting S_SurvivorDetectorMaxDist          20.0        as "survivor detector max distance"
#Setting S_CanLeaveMapFor                   3000        as "can leave battlefield for (ms)"
#Setting S_ForceSpecAfter                   60000       as "force inactive players to spectators after (ms)"
#Setting S_CanIdleAfterSpawn                10000       as "player can be idle after spawning for (ms)"
#Setting S_InfectOnPreparationRespawn       True        as "infect on respawn during preparation"
#Setting S_ForceFirstInfected               False       as "choose first infected even if someone got infected"
#Setting S_ProtectionQueueSize              1           as "size of protection queue of not being first infected"
#Setting S_ClosedCondGateValue              0.3675      as "<hidden>" //as "value of closed conditional gate"
#Setting S_KnockoutMode                     False       as "enable knockout mode"
#Setting S_KnockoutMode_FirstStage_Rounds   8           as "number of rounds for first stage knockout"
#Setting S_KnockoutMode_LastStage_Rounds    5           as "number of rounds for last stage knockout"
#Setting S_KnockoutMode_LastStage_Players   8           as "number of required players for last stage"
#Setting S_KnockoutMode_LastStage_NewScores True        as "reset scores for last knockout stage"
#Setting S_KnockoutMode_Kick                False       as "knockout method (kick=True, spec=False)"
#Setting S_SendBigInfectionMessage          2000        as "send old style big infection message (ms)"
#Setting S_ScoresTableDelay                 0           as "<hidden>"
#Setting S_RoundPauseTime                   4000        as "<hidden>"
#Setting S_MatchPauseTime                   6000        as "<hidden>"
#Setting S_Debug                            False       as "<hidden>" //as "display debug information into chat and console"
#Setting S_SurvivorStamina                  1.0         as "survivor stamina (0.1-3.0)"
#Setting S_SurvivorStaminaGain              0.7         as "survivor stamina gain (0.0-1.0,10)"
#Setting S_InfectedStamina                  2.0         as "infected stamina (0.1-3.0)"
#Setting S_InfectedStaminaGain              1.0         as "infected stamina gain (0.0-1.0,10)"
#Setting S_SurvivorRespawnArmor             1           as "survivor respawn armor"
#Setting S_SurvivorMaxArmor                 1           as "survivor maximum armor"
#Setting S_InfectedRespawnArmor             2           as "infected respawn armor"
#Setting S_InfectedMaxArmor                 2           as "infected maximum armor"
#Setting S_InfectedShoot                    1           as "allow first N infected to shoot"
#Setting S_InfectedAmmoGain                 1.0         as "infected ammo gain"
#Setting S_InfectedLaserMax                 0           as "<hidden>"
#Setting S_InfectedRocketMax                1           as "infected maximum rockets"
#Setting S_InfectedNucleusMax               0           as "<hidden>"
#Setting S_InfectedArrowMax                 0           as "<hidden>"
#Setting S_SurvivorAmmoGain                 1.0         as "survivor ammo gain"
#Setting S_SurvivorLaserMax                 1           as "<hidden>"
#Setting S_SurvivorRocketMax                4           as "survivor maximum rockets"
#Setting S_SurvivorNucleusMax               1           as "<hidden>"
#Setting S_SurvivorArrowMax                 2           as "<hidden>"
#Setting S_BlacklistURL	                    ""          as "<hidden>" // URL of the blacklist file
#Setting S_InfectFirstLeaver                True        as "<hidden>" //as "infect player who leave being the only first infected"

#Const   C_MaxSignedInteger                 2147483647

#Const   C_ModeInfection                    "Infection"
#Const   C_ModePursuit                      "Pursuit"

#Const   C_MinimalPlayerCount               2
#Const   C_InfectOnRespawn                  True        //as "infect on respawn"
#Const   C_InfectionTick                    30
#Const   C_SurvivorColor                    <1.0, 0.0, 0.0>
#Const   C_SurvivorHasShield                True
#Const   C_SurvivorIsHighlighted            True
#Const   C_SurvivorEnergyLevel              1.0
#Const   C_InfectedColor                    <0.0, 0.5, 0.0>
#Const   C_InfectedHasShield                True
#Const   C_InfectedIsHighlighted            False
#Const   C_InfectedEnergyLevel              1.0

#Const   C_MainManialinkLayer               "Infection_MainManialinkLayer"

#Const   C_SurvivorTeamId                   0
#Const   C_InfectedTeamId                   1
#Const   C_SurvivorClanNum                  1
#Const   C_InfectedClanNum                  2

#Const   C_TxtInfectedBy                    "Infected by: "
#Const   C_TxtInfectedFooter                "Infect $f00survivors$z!"
#Const   C_TxtSurvivorFooter                "Avoid $080infected $zplayers!"
#Const   C_TxtSpectatorFooter               ""

#Const   C_TxtRules                         "Free for all. You spawn as a survivor, if you die you respawn infected. Infected can infect other players by touching them."
#Const   C_TxtRoundEnd                      "A round ends either if no survivors are left or if the time limit is reached."

#Const   C_PlayerIsIdle                     "$z$s is idle."
#Const   C_WasIdleTooLongMovingToSpec       "$z$s was idle for too long. Moving to spectators."
#Const   C_IdlePlayerWarning                "$sYou are considered inactive!"

#Const   C_TxtYouInfectedA                  "$0f0You infected $fff%1"
#Const   C_TxtAInfectedYou                  "%1 $z$s$0f0infected you"
#Const   C_TxtAInfectedB                    "%1 $z$sinfected %2"

#Const   C_TxtPlayerDrowned                 "$z$s drowned in water!"
#Const   C_TxtPlayerInfectedByWater         "%1 $z$swas infected by water!"
#Const   C_TxtPlayerWasEliminated           "%1 $z$swas very curious and got aids!"

#Const   C_TxtAllPlayersInfected            "All players are infected!"
#Const   C_TxtTimeLimitReached              "Time limit reached!"
#Const   C_TxtNPlayersSurvivied             "$f00%1 $fffplayer(s) survived!"
#Const   C_TxtNoMoreInfected                "No more infected players!"
#Const   C_TxtAtLeastNPlayersNeeded         "At least $f00%1$z players are needed!"
#Const   C_TxtWaitingPlayers                "$f92Waiting for Players"

#Const   C_TxtGetBackToBattleField          "Get back to the battlefield!"
#Const   C_TxtYouWillBeInfectedInX          "You will be infected in $080%1"

#Const   C_LastSurvivorMsgDuration          6000
#Const   C_LastSurvivorMsgPriority          2

#Const   C_ArmorUnit                        100
#Const   C_ArmorReplenishGain               300

#Const   C_StaminaRealUnit                  1.0
#Const   C_StaminaIntUnit                   3600
#Const   C_StaminaMinGain                   0.0
#Const   C_StaminaMaxGain                   1.0

#Const   C_Cond_TxtPrefix                   "$f00[CondLandmark] $z$s"

#Const   C_Cond_CountSource                 0
#Const   C_Cond_Comparison                  1
#Const   C_Cond_Value                       2
#Const   C_Cond_Chain                       3

#Const   C_Cond_TxtPlayers                  "P"
#Const   C_Cond_TxtSurvivors                "S"
#Const   C_Cond_TxtInfected                 "I"

#Const   C_Cond_Players                     0
#Const   C_Cond_Survivors                   1
#Const   C_Cond_Infected                    2

#Const   C_Cond_Comparison_LT               0
#Const   C_Cond_Comparison_EQ               1
#Const   C_Cond_Comparison_GT               2

#Const   C_Cond_Chain_None                  -1
#Const   C_Cond_Chain_AND                   0
#Const   C_Cond_Chain_OR                    1

#Const   C_MapSetting_Water                         "W"
#Const   C_MapSetting_WaterProperty_TxtEliminates   "E"
#Const   C_MapSetting_WaterProperty_TxtProtects     "P"
#Const   C_MapSetting_WaterProperty_TxtInfects      "I"
#Const   C_MapSetting_WaterProperty_TxtHeals        "H"

#Const   C_MapSetting_Gates                         "G"
#Const   C_MapSetting_GatesCanBeClosedDuringRound   "C"
#Const   C_Knockout_TxtKickAfterStartMsg    "You are not allowed to join after knockout mode has been started!"
#Const   C_Knockout_TxtKickWorstScoreMsg    "You had the worst score! You are knocked out!"
#Const   C_Knockout_TxtPrefix               "$f00[Knockout]$z$s "
#Const   C_Knockout_Stage_None              0
#Const   C_Knockout_Stage_Init              1
#Const   C_Knockout_Stage_First             10
#Const   C_Knockout_Stage_Last              20

#Const   C_UnexpectedBehaviour "Unexpected behaviour!\nThis must not happen!\nWhere: %1\nData: %2"

#Const   C_Inf_XmlRpc_InfectByLogin     "Inf_Infect"
#Const   C_Inf_XmlClb_Infected          "Inf_Infection"

/* -------------------------------------- */
// Globals
/* -------------------------------------- */

declare Boolean G_IsDebugging;

declare Integer G_RoundNb;

declare Boolean G_IsPaused;
declare Boolean G_QuickRestart;

declare Integer G_PrevPlayerProcTime;
declare Boolean G_InfectionStarted;

declare Integer G_InfectedPlayerCount;
declare Ident   G_FirstInfectedId;

declare Boolean G_InfectPrevFirstInfected;
declare Text    G_PrevFirstInfectedLogin;

declare Ident[] G_ProtectionQueue;

declare CSmMapLandmark[] G_CondGates_Up_Always;
declare CSmMapLandmark[] G_CondGates_Up_EachRound;

declare CSmMapLandmark[] G_AllSpawns;
declare CSmMapLandmark[] G_SurvivorSpawns;
declare CSmMapLandmark[] G_InfectedSpawns;

// No bitfield operations, so declaring bunch of booleans
declare Boolean G_MapSetting_WaterHasEffects;

declare Boolean G_MapSetting_WaterForSurvivors_Eliminates;
declare Boolean G_MapSetting_WaterForSurvivors_Protects;
declare Boolean G_MapSetting_WaterForSurvivors_Infects;
declare Boolean G_MapSetting_WaterForSurvivors_Heals;

declare Boolean G_MapSetting_WaterForInfected_Eliminates;
declare Boolean G_MapSetting_WaterForInfected_Protects;
declare Boolean G_MapSetting_WaterForInfected_Heals;

declare Boolean G_MapSetting_GatesCanBeClosedDuringRound;

// For knockout mode
declare Ident[] G_Knockout_Players;
declare Integer G_Knockout_Stage;
declare Integer G_Knockout_RoundNb;
declare Boolean G_Knockout_FirstRound;

***Match_LogVersions***
***
Log::RegisterScript(ScriptName                   , Version);
Log::RegisterScript(Layers::GetScriptName()      , Layers::GetScriptVersion());
Log::RegisterScript(Message::GetScriptName()     , Message::GetScriptVersion());
Log::RegisterScript(Tabs::GetScriptName()        , Tabs::GetScriptVersion());
Log::RegisterScript(SM::GetScriptName()          , SM::GetScriptVersion());
Log::RegisterScript(IScores::GetScriptName()     , IScores::GetScriptVersion());
Log::RegisterScript(SpawnScreen::GetScriptName() , SpawnScreen::GetScriptVersion());
Log::RegisterScript(Manialink::GetScriptName()   , Manialink::GetScriptVersion());
Log::RegisterScript(ITree::GetScriptName()       , ITree::GetScriptVersion());
Log::RegisterScript(Blacklist::GetScriptName()   , Blacklist::GetScriptVersion());
***

***Match_InitServer***
***
Debug("InitServer");

UIManager.UILayerDestroyAll();
SM::SetupDefaultVisibility();
UIManager.UIAll.AltMenuNoCustomScores  = True;
UIManager.UIAll.AltMenuNoDefaultScores = True;
UIManager.UIAll.OverlayHide321Go       = True;
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
***

***Match_StartServer***
***
Debug("StartServer");

IScores::Load();
ITree::Load();
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer([
    "InfTreeTab" => "Statistics",
    "ScoresTab"  => "Rankings",
    "TopTab"     => "Buddies"
], 30, -5, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);

Layers::Create(C_MainManialinkLayer, GenerateManialink());
Layers::Attach(C_MainManialinkLayer);

ChannelProgression::Enable(S_IsChannelServer);
***

***Match_StartMap***
***
Debug("StartMap");

// Check if script is running in test environment (from map editor or local server)
if(ServerLogin == "") {
    // force debug to true
    G_IsDebugging = True;
    Debug("Test environment detected! Forcing S_Debug to True.");
} else {
    if(G_IsDebugging && !S_Debug) {
        Debug("Debugging disabled!");
    }
    G_IsDebugging = S_Debug;
    if(S_Debug) {
        Debug("Debugging enabled!");
    }
}

// Required for manialink clan colors
Teams[C_SurvivorTeamId].ColorPrimary = C_SurvivorColor;
Teams[C_InfectedTeamId].ColorPrimary = C_InfectedColor;

UIManager.UIAll.MarkersXML = "";

G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
G_AllSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();

G_MapSetting_WaterHasEffects              = False;

G_MapSetting_WaterForSurvivors_Eliminates = False;
G_MapSetting_WaterForSurvivors_Protects   = False;
G_MapSetting_WaterForSurvivors_Infects    = False;
G_MapSetting_WaterForSurvivors_Heals      = False;

G_MapSetting_WaterForInfected_Eliminates  = False;
G_MapSetting_WaterForInfected_Protects    = False;
G_MapSetting_WaterForInfected_Heals       = False;

G_MapSetting_GatesCanBeClosedDuringRound  = False;

foreach(Landmark in MapLandmarks) {
    Debug("Checking landmark `" ^ Landmark.Tag ^ "`");
    declare Tags = TL::Split("_", Landmark.Tag);
    switch(Tags[0]) {
        case "Spawn":
        {
            SetupCustomSpawn(Landmark);
        }
        case "Tornado":
        {
            if(Tags.count == 2) {
                OffZoneCenterLandmarkId = Landmark.Id;
                OffZoneRadius = TL::ToReal(Tags[1]);

                Debug("Tornado radius: " ^ OffZoneRadius);
            } else {
                Debug("Tornado has no radius");
            }
        }
        case "Gate":
        {
            if(SetupGateConditions(Landmark)) {
                declare Boolean UpdateAlways for Landmark = False;
                if(UpdateAlways)
                    G_CondGates_Up_Always.add(Landmark);
                else
                    G_CondGates_Up_EachRound.add(Landmark);
                SetupConditionalGate(Landmark);
            }
        }
        case "Settings":
        {
            if(Tags.count > 1) {
                SetupMapSettings(Tags[1]);
            }
        }
    }
}

declare Text ModeName = C_ModeInfection;
if(S_PursuitMode)
    ModeName = C_ModePursuit;

SpawnScreen::SetModeName(ModeName);
SpawnScreen::AddSubsection("Rules", C_TxtRules, 0.);
SpawnScreen::AddSubsection("Round end", C_TxtRoundEnd, 30.);

declare Text MatchEnd;
MatchEnd ^= "A match ends after ";
if(S_RoundLimit > 0 && S_ScoreLimit == 0) {
    MatchEnd ^= S_RoundLimit ^ " round(s).";
} else if(S_RoundLimit == 0 && S_ScoreLimit > 0) {
    MatchEnd ^= "some player gets at least " ^ S_ScoreLimit ^ " point(s).";
} else {
    MatchEnd ^= S_RoundLimit ^ ", or after some player gets at least " ^ S_ScoreLimit ^ " point(s).";
}
SpawnScreen::AddSubsection("Match end", MatchEnd, 55.);

declare Text Description;
Description ^= "- $" ^ TL::ColorToText(C_SurvivorColor) ^ "Survivors$z VS $" ^ TL::ColorToText(C_InfectedColor) ^ "Infected$z;";
if(S_RewardFirstInfected > 0.0) {
    Description ^= "\n- the first infected gets " ^ S_RewardFirstInfected ^ "*(number of players - 1) additional points if all players are infected;";
}
if(S_InfectedShoot > 0) {
    if(S_InfectedShoot == 1) {
        Description ^= "\n- the first infected can shoot until there is a second infected;";
    } else {
        Description ^= "\n- the first " ^ S_InfectedShoot ^ " infected players can shoot until there is " ^ (S_InfectedShoot+1) ^ " infected players;";
    }
}
if(S_InfectionArmorBonus > 0) {
    Description ^= "\n- when an infected players infects another player he regenerates " ^ S_InfectionArmorBonus ^ " armor(s);";
}
SpawnScreen::AddSubsection("Description", Description, 80.);

SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores();
SpawnScreen::CreatePrettyRules(ModeName);
***

***Match_InitMatch***
***
Debug("InitMatch");

IScores::MatchBegin();

InitGame();
***

***Match_InitRound***
***
Debug("InitRound");

G_PrevPlayerProcTime = -1;
G_InfectionStarted   = False;

UseClans       = S_UseClans;
UseForcedClans = S_UseClans;

UseSameWallJump  = S_UseSameWallJump;
UsePvPWeapons    = !S_PursuitMode;
UsePvPCollisions = S_UsePVPCollisions;
***


***Match_StartRound***
***
Debug("StartRound");

G_RoundNb += 1;

IScores::RoundBegin();

if(S_KnockoutMode) {
    if(G_Knockout_Stage == C_Knockout_Stage_Init) {
        G_Knockout_Players.clear();
        foreach(Player in Players) {
            G_Knockout_Players.add(Player.Id);
        }
        if(G_Knockout_Players.count >= C_MinimalPlayerCount) {
            if(G_Knockout_Players.count > S_KnockoutMode_LastStage_Players) {
                KnockoutSetStage(C_Knockout_Stage_First);
            } else {
                KnockoutSetStage(C_Knockout_Stage_Last);
            }
        }
        G_Knockout_FirstRound = True;
    } else {
        G_Knockout_FirstRound = False;
    }
}

UpdateScoresTableFooter();

UIManager.UIAll.UISequence      = CUIConfig::EUISequence::Playing;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Default;

// Don't erase pause message
if(!G_IsPaused) {
    Message::SetDefaultAllMessages("");
    Message::CleanAllMessages();
}

G_FirstInfectedId        = NullId;
G_PrevFirstInfectedLogin = "";
G_InfectedPlayerCount    = 0;

// Required to uninfect all players
foreach(Player in AllPlayers) {
    InitializePlayer(Player);
}

StartTime = Now;
if(IsOperating()) {
    EndTime = StartTime + S_PreparationTime;

    // Update conditional gates (allow closing)
    foreach(Gate in G_CondGates_Up_EachRound) {
        UpdateGateStatus(Gate, True);
    }
    foreach(Gate in G_CondGates_Up_Always) {
        UpdateGateStatus(Gate, True);
    }

    CalcAndDisplayInfChance();

    Debug("Protection queue: " ^ G_ProtectionQueue);

    if(S_KnockoutMode) {
        if(G_Knockout_Stage == C_Knockout_Stage_First) {
            declare Integer ToKnockout = GetNbOfPlayersToKO();
            if(ToKnockout > 0) {
                KnockoutMessage(ToKnockout ^ " worst player(s) will be knocked out this round!");
            } else {
                KnockoutMessage("No one will be knockout this round!");
            }
        }
    }
} else {
    EndTime = -1;

    if(PlayersCount() < C_MinimalPlayerCount) {
        Message::SetDefaultBigMessage(C_TxtWaitingPlayers);
        Message::SetDefaultStatusMessage(
            TL::Compose(C_TxtAtLeastNPlayersNeeded, TL::ToText(C_MinimalPlayerCount))
        );
    }

    // Open all gates
    foreach(Gate in G_CondGates_Up_EachRound) {
        SetGateOpened(Gate, True);
    }
    foreach(Gate in G_CondGates_Up_Always) {
        SetGateOpened(Gate, True);
    }

    // Hide infected count
    G_InfectedPlayerCount = -1;
}

// Clear infection tree
ITree::Clear();

CropProtectionQueue();

G_QuickRestart = False;
***

***OnNewPlayer***
***

declare UI <=> UIManager.GetUI(Player);

if(IsAllowedToPlay(Player)) {
    if(UI != Null) {
        UI.ForceSpectator = False;
    }
    // InitializePlayer only if the sync was required (last sync was @ different round)
    if(IScores::SyncPlayerInfo(Player)) {
        InitializePlayer(Player);
    }
    if(IsOperating()) {
        if((G_InfectionStarted && S_InfectNewPlayers)
        || S_InfectFirstLeaver && G_PrevFirstInfectedLogin == Player.User.Login
        ) {
            if(!IsInfected(Player)) {
                Infect(Player, Null, "", True);
            }
        }
    }
    if(S_KnockoutMode) {
        if(G_Knockout_FirstRound) {
            // Add player to k.o. players because he's allowed to play
            // and only if first round, because all players are allowed to play during the pause
            if(!G_Knockout_Players.exists(Player.Id))
                G_Knockout_Players.add(Player.Id);

            if(G_Knockout_Stage == C_Knockout_Stage_Last) {
                if(G_Knockout_Players.count > S_KnockoutMode_LastStage_Players) {
                    KnockoutSetStage(C_Knockout_Stage_First);
                    UpdateScoresTableFooter();
                }
            }
        }
    }
} else {
    KnockoutUser(Player.User, C_Knockout_TxtKickAfterStartMsg);
}

UpdateScoresStatus(Player);

if(UI != Null) {
    Tabs::UseTabs(UI, "ScoresTab");
}

***

***OnNewSpectator***
***
InitializePlayer(Spectator);

UpdateScoresStatus(Spectator);

declare UI <=> UIManager.GetUI(Spectator);

if(G_ProtectionQueue.exists(Spectator.Id)) {
    Debug("Removing " ^ Spectator.Name ^ "$z$s from protection queue");
    G_ProtectionQueue.remove(Spectator.Id);
}

if(UI != Null) {
    Tabs::UseTabs(UI, "ScoresTab");
    UI.SpectatorForcedClan       = 0;
    UI.SpectatorForceCameraType  = 15;
}

***

***Match_Yield***
***
Message::Loop();
Tabs::XmlRpcLoop();
IScores::Loop();
ITree::Loop();
if(S_BlacklistURL != "") {
    Blacklist::Loop(S_BlacklistURL);
}
***

***Match_PlayLoop***
***
if(G_PrevPlayerProcTime + C_InfectionTick < Now) {
    G_PrevPlayerProcTime = Now;

    if(IsOperating())
        OperativePlayLoop();
    else
        NonoperationalPlayLoop();
}

if(EndTime > -1 && EndTime <= Now) {
    if(!G_InfectionStarted && IsOperating()) {
        // Begin infection round
        G_InfectionStarted = True;

        if(S_TimeLimit > 0) {
            EndTime = Now + S_TimeLimit;
        } else {
            EndTime = -1;
        }

        // Infect first leaver (should be before GetFirstInfected, because it resets G_PrevFirstInfectedLogin)
        if (G_InfectPrevFirstInfected && S_InfectFirstLeaver) {
            foreach(Player in Players) {
                if (G_PrevFirstInfectedLogin == Player.User.Login) {
                    Infect(Player, Null, "", True);
                    break;
                }
            }
        }

        declare FirstInfected = GetFirstInfected();
        if(FirstInfected != Null) {
            if(!IsInfected(FirstInfected)) {
                Infect(FirstInfected);
            }

            Debug("Adding " ^ FirstInfected.Name ^ "$z$s to protection queue");
            G_ProtectionQueue.add(FirstInfected.Id);
            CropProtectionQueue();

            Message::SendStatusMessage("$iLet the infection begin...", 4000, 1);
            Message::SendBigMessage(FirstInfected, "$360First Infected!", 4000, 1);
            foreach(Survivor in AllPlayers) {
                if(IsInfected(Survivor))
                    continue;

                Message::SendBigMessage(Survivor, FirstInfected.Name ^ "$z$s$360 is the first infected!", 4000, 1);
            }
        } else {
            // This must not happen
            log(TL::Compose(C_UnexpectedBehaviour, "Choosing first infected", "Null"));
            MB_StopRound();
        }
    } else {
        // End infection round
        MB_StopRound();
    }
}

foreach(Event in PendingEvents) {
    switch(Event.Type) {
        case CSmModeEvent::EType::OnHit:
        {
            if(Event.Shooter == Event.Victim
            || IsProtectedByMap(Event.Victim)
            || !IsOperating()
            ) {
                Discard(Event);
                continue;
            }
            Event.Damage = ML::Clamp(Event.Damage, 0, S_MaxDamage);
            declare ShooterInfected = IsInfected(Event.Shooter);
            declare VictimInfected  = IsInfected(Event.Victim);
            if(VictimInfected && !ShooterInfected) {
                // OnSurvivorHitInfected
                if(S_HitInfectedScore >= 0) {
                    OnHit(Event, S_HitInfectedScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && !ShooterInfected) {
                // OnSurvivorHitSurvivor
                if(S_PVP && S_HitSurvivorScore >= 0) {
                    OnHit(Event, S_HitSurvivorScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && ShooterInfected) {
                // OnInfectedHitSurvivor
                Infect(Event.Victim, Event.Shooter);
                Discard(Event);
            } else {
                // OnInfectedHitInfected
                Discard(Event);
            }
        }
        case CSmModeEvent::EType::OnPlayerAdded:
        {
            if(S_BlacklistURL != "") {
                if(Event.Player != Null) {
                    Blacklist::CheckUser(Event.Player.User);
                }
            }
        }
        default:
        {
            PassOn(Event);
        }
    }
}

// Should be a command, but maniascript doesn't support hidden commands
if(S_Paused && !G_IsPaused) {
    Pause();
} else if(!S_Paused && G_IsPaused) {
    Unpause();
}
if(S_KnockoutMode && G_Knockout_Stage == C_Knockout_Stage_None) {
    KnockoutEnable();
} else if(!S_KnockoutMode && G_Knockout_Stage != C_Knockout_Stage_None) {
    KnockoutDisable();
}

// Should be in `***Yield***`, but it depends on InfectByLogin
InfectionXmlRpcLoop();

declare Integer Prev_PlayerCount         for This = -1;
declare Integer Prev_KOPlayerCount       for This = -1;
declare Integer Prev_InfectedPlayerCount for This = -1;

declare Boolean PlayerCountChanged = False;

// The most reliable way of checking of player count changes.
// It's done in one place, so updated only once per playloop iteration.
if(Prev_PlayerCount != Players.count
|| Prev_KOPlayerCount != G_Knockout_Players.count
) {
    PlayerCountChanged = True;

    if(S_KnockoutMode) {
        // Cleanup allowed players
        foreach(PlayerId in G_Knockout_Players) {
            if(!Players.existskey(PlayerId))
                G_Knockout_Players.remove(PlayerId);
        }
    }

    // If it's enough players now, restart!
    // Or if it's not enough players now, restart and display message!
    if(Prev_PlayerCount <  C_MinimalPlayerCount && PlayersCount() >= C_MinimalPlayerCount
    || Prev_PlayerCount >= C_MinimalPlayerCount && PlayersCount() <  C_MinimalPlayerCount
    ) {
        if(!G_IsPaused)
            RestartGame();
    }

    declare netwrite Integer Net_PlayerCount for Teams[0];
    Net_PlayerCount    = PlayersCount();
    Prev_PlayerCount   = Players.count;
    Prev_KOPlayerCount = G_Knockout_Players.count;

    // Infected player count might be changed too
    G_InfectedPlayerCount = CountInfected();

    if(!G_InfectionStarted && IsOperating())
        CalcAndDisplayInfChance();
}
if(Prev_InfectedPlayerCount != G_InfectedPlayerCount) {
    PlayerCountChanged = True;

    // If previously infected could shoot and now they cannot shoot, or
    // infected couldn't shoot previously and now they can shoot
    if((Prev_InfectedPlayerCount <= S_InfectedShoot && G_InfectedPlayerCount >  S_InfectedShoot) ||
        Prev_InfectedPlayerCount >  S_InfectedShoot && G_InfectedPlayerCount <= S_InfectedShoot)
    {
        // Re-setup infector weapons
        foreach(Infected in Players) {
            if(!IsInfected(Infected)) {
                continue;
            }
            SetupInfectedWeapons(Infected);
        }
    }

    // If someone got infected before first infected
    // and S_ForceFirstInfected is False, then remember the first infected
    // and force the infection begin
    if(!G_InfectionStarted && G_FirstInfectedId == NullId && !S_ForceFirstInfected && G_InfectedPlayerCount > 0) {
        // Get (un)lucky first infected
        declare Integer firstInfectionTime = C_MaxSignedInteger;
        foreach(Infected in Players) {
            if(!IsInfected(Infected) || !IsAllowedToPlay(Infected)) {
                continue;
            }
            declare Integer InfectionTime for Infected = Now;
            if(firstInfectionTime > InfectionTime) {
                firstInfectionTime = InfectionTime;
                G_FirstInfectedId = Infected.Id;
                G_PrevFirstInfectedLogin = Infected.User.Login;
            }
        }
        // If the unlucky first infected was found,
        // force infection begin
        if(G_FirstInfectedId != NullId && Players.existskey(G_FirstInfectedId)) {
            EndTime = Now;
        }
    }

    declare netwrite Integer Net_InfectedCount for Teams[0];
    Prev_InfectedPlayerCount = G_InfectedPlayerCount;
    Net_InfectedCount        = G_InfectedPlayerCount;
}
if(PlayerCountChanged) {
    // If player count (survivor or infected) changed, update conditional gates
    PlayerCountChanged = False;
    foreach(Gate in G_CondGates_Up_Always) {
        // Permit only opening gates during the round
        UpdateGateStatus(Gate, G_MapSetting_GatesCanBeClosedDuringRound);
    }
    UpdateModeStatusMessage();
}

if((G_InfectionStarted && G_InfectedPlayerCount == 0) || (G_InfectedPlayerCount >= PlayersCount())) {
    // End round only if operating
    if(IsOperating()) {
        MB_StopRound();
    }
}

***

***Match_EndRound***
***
Debug("EndRound");

SM::UnspawnAllPlayers();
DestroyAllBotPlayers();

if(!G_QuickRestart) {
    if(S_RewardFirstInfected > 0.0 && Players.existskey(G_FirstInfectedId)) {
        declare FirstInfected <=> Players[G_FirstInfectedId];
        IScores::AddPoints(FirstInfected, ML::NearestInteger(G_InfectedPlayerCount * S_RewardFirstInfected));
    }

    IScores::RoundEnd();

    // Clean UI
    Message::SetDefaultAllMessages("");
    Message::CleanAllMessages();

    // Enable EndRound sequence
    UIManager.UIAll.UISequence      = CUIConfig::EUISequence::EndRound;
    UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;

    declare Text BigMessage    = "";
    declare Text StatusMessage = "";
    if(G_InfectedPlayerCount >= PlayersCount()) {
        BigMessage = C_TxtAllPlayersInfected;
    } else if(G_InfectedPlayerCount == 0) {
        BigMessage = C_TxtNoMoreInfected;
        G_RoundNb -= 1;
    } else {
        BigMessage    = C_TxtTimeLimitReached;
        StatusMessage = TL::Compose(C_TxtNPlayersSurvivied, TL::ToText(PlayersCount() - G_InfectedPlayerCount));
    }
    UIManager.UIAll.BigMessage    = BigMessage;
    UIManager.UIAll.StatusMessage = StatusMessage;

    // Check for first infected leaver
    if (G_InfectedPlayerCount == 1 && EndTime > 0 && S_InfectFirstLeaver) {
        G_InfectPrevFirstInfected = True;
    } else {
        G_InfectPrevFirstInfected = False;
    }

    // Check for limits
    if(!S_KnockoutMode) {
        // Regular mode limits

        if(S_RoundLimit > 0 && G_RoundNb >= S_RoundLimit) {
            MB_StopMap();
        } else if(S_ScoreLimit > 0) {
            foreach(Player in Players) {
                if(Player.Score != Null && Player.Score.Points >= S_ScoreLimit) {
                    MB_StopMap();
                    break;
                }
            }
        }

    } else if(G_InfectedPlayerCount > 0) { // only process k.o. round if infected players didn't leave
        // Knockout mode limits

        declare Integer ToKnockout = GetNbOfPlayersToKO();

        G_Knockout_RoundNb += 1;

        declare Integer RoundsLeft = S_KnockoutMode_LastStage_Rounds - G_Knockout_RoundNb;

        if(G_Knockout_Stage != C_Knockout_Stage_Last) {
            // First stage

            declare Integer NewPlayersCount = PlayersCount() - ToKnockout;

            if(NewPlayersCount < S_KnockoutMode_LastStage_Players) {
                NewPlayersCount = S_KnockoutMode_LastStage_Players;
                ToKnockout = PlayersCount() - NewPlayersCount;
            }

            // Knockout
            if(ToKnockout > 0) {
                declare Text KnockMessage   = "Knocking out $080" ^ ToKnockout ^ "$z$s worst player(s): ";
                declare Text KnockedPlayers = "";
                declare Scores = PlayersScore(G_Knockout_Players).sort();
                foreach(PlayerId => Score in Scores) {
                    declare Player <=> Players[PlayerId];
                    G_Knockout_Players.remove(PlayerId);
                    KnockoutUser(Player.User, C_Knockout_TxtKickWorstScoreMsg);
                    if(KnockedPlayers != "")
                        KnockedPlayers ^= "$z$s, ";
                    KnockedPlayers ^= Player.Name;
                    ToKnockout -= 1;
                    if(ToKnockout == 0)
                        break;
                }
                KnockoutMessage(KnockMessage ^ KnockedPlayers);
            }

            if(NewPlayersCount <= S_KnockoutMode_LastStage_Players) {
                KnockoutSetStage(C_Knockout_Stage_Last);

                KnockoutMessage("Only $080" ^ NewPlayersCount ^ "$z$s player(s) left!");
                KnockoutMessage("No more players will be knocked out!");
                KnockoutMessage("Get the maximum amount of points to win!");
            }
        } else {
            // Last stage

            if(RoundsLeft <= 0) {
                // End of knockout match
                MB_StopMap();
            } else {
                if(RoundsLeft > 1) {
                    KnockoutMessage(RoundsLeft ^ " round(s) left!");
                } else {
                    KnockoutMessage("Last round!");
                }
            }
        }

        UpdateScoresTableFooter();

        G_Knockout_FirstRound = False;
    }

    MB_Sleep(S_ScoresTableDelay);

    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

    MB_Sleep(S_RoundPauseTime);

    UIManager.UIAll.BigMessageSound      = CUIConfig::EUISound::Silence;
    UIManager.UIAll.BigMessage           = "";
    UIManager.UIAll.StatusMessage        = "";
    UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}

StartTime = -1;
EndTime   = -1;

***

***Match_EndMatch***
***
Debug("EndMatch");

IScores::MatchEnd();

***

***Match_EndMap***
***
Debug("EndMap");

UIManager.UIAll.BigMessage    = "";
UIManager.UIAll.StatusMessage = "";

declare CSmPlayer[] MaxScores;
declare Integer MaxScore = 0;
foreach(Player in Players) {
    if(Player.Score != Null) {
        if(MaxScore < Player.Score.Points) {
            MaxScores.clear();
            MaxScores.add(Player);
            MaxScore = Player.Score.Points;
        } else if (MaxScore == Player.Score.Points) {
            MaxScores.add(Player);
        }
    }
}

if(MaxScore == 0) {
    UIManager.UIAll.BigMessage = _("|Match|Draw");
} else if(MaxScores.count > 0) {
    declare Text PlayerNames = MaxScores[0].Name;
    for(I, 1, MaxScores.count - 1) {
        if(I < MaxScores.count - 1) {
            PlayerNames ^= ", " ^ MaxScores[I].Name;
        } else {
            if(MaxScores.count > 2)
                PlayerNames ^= ",";
            PlayerNames ^= " and " ^ MaxScores[I].Name;
        }
    }

    if(MaxScores.count > 1) {
        UIManager.UIAll.BigMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    } else {
        UIManager.UIAll.StatusMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    }
}

UIManager.UIAll.UISequence              = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound         = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence              = CUIConfig::EUISequence::Podium;

MB_Sleep(S_MatchPauseTime);

UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage              = "";
UIManager.UIAll.StatusMessage           = "";

G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
G_AllSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();
***

***Match_EndServer***
***
Debug("EndServer");

SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
UIManager.ResetAll();
UIManager.UILayerDestroyAll();

Layers::Detach(C_MainManialinkLayer);
Layers::Destroy(C_MainManialinkLayer);

IScores::Unload();
***

Void Debug(Text _Message) {
    if(G_IsDebugging) {
        UIManager.UIAll.SendChat("$fff[Infection] " ^ _Message);
        log("[Infection] " ^ _Message);
    }
}

Void KnockoutSetStage(Integer _Stage) {
    if(G_Knockout_Stage == _Stage)
        return;

    switch(_Stage) {
        case C_Knockout_Stage_Last:
        {
            if(S_KnockoutMode_LastStage_NewScores) {
                if(G_Knockout_Stage == C_Knockout_Stage_First) {
                    // Reset scores only if previous stage was `first`
                    IScores::MatchEnd();
                    IScores::MatchBegin();
                }
            }
        }
    }

    G_Knockout_Stage = _Stage;
    G_Knockout_RoundNb = 0;
}

Void KnockoutInit() {
    G_Knockout_Players.clear();
    if(S_KnockoutMode) {
        KnockoutSetStage(C_Knockout_Stage_Init);
    } else {
        KnockoutSetStage(C_Knockout_Stage_None);
    }
}

Void InitGame() {
    G_InfectedPlayerCount = 0;

    Debug("Clearing protection queue");
    G_ProtectionQueue.clear();

    KnockoutInit();
}

Void RestartGame() {
    InitGame();

    G_QuickRestart = True;
    MB_RestartScript();
}

Void RestartRound() {
    G_QuickRestart = True;
    MB_StopRound();
    G_RoundNb -= 1;
}

Boolean IsKnockoutStarted() {
    return S_KnockoutMode && !G_Knockout_FirstRound && G_Knockout_Stage > C_Knockout_Stage_Init;
}

// IsOperating returns whether the Script can operate in a normal mode
Boolean IsOperating() {
    if(G_IsPaused)
        return False;
    if(IsKnockoutStarted()) {
        if(G_Knockout_Players.count < C_MinimalPlayerCount)
            return False;
    } else {
        if(Players.count < C_MinimalPlayerCount)
            return False;
    }
    return True;
}

Integer PlayersCount() {
    if(IsKnockoutStarted()) {
        return G_Knockout_Players.count;
    }
    return Players.count;
}

Boolean IsAllowedToPlay(CSmPlayer _Player) {
    if(IsOperating() && IsKnockoutStarted()) {
        return G_Knockout_Players.exists(_Player.Id);
    }
    return True;
}

Boolean IsInfected(CSmPlayer _Player) {
    if(_Player != Null) {
        declare Boolean Infected for _Player = False;
        return Infected;
    }
    return False;
}

Integer CountInfected() {
    if(!IsOperating())
        return -1;
    declare Integer Count = 0;
    foreach(Player in Players) {
        if(IsInfected(Player) && IsAllowedToPlay(Player))
            Count += 1;
    }
    return Count;
}

Boolean CropProtectionQueue() {
    declare Boolean Cropped = False;
    declare Integer CropTo = S_ProtectionQueueSize;
    if(CropTo >= PlayersCount())
        CropTo = PlayersCount() - 1;
    if(CropTo <= 0)
        return False;
    while(G_ProtectionQueue.count > CropTo) {
        G_ProtectionQueue.removekey(0);
        Cropped = True;
    }
    return Cropped;
}

Real ML__FMod(Real _Value, Real _Mod) {
    return _Value - ML::ToReal(ML::FloorInteger(_Value / _Mod)) * _Mod;
}

Real RealRandom(Real _Max) {
    declare Real Rand = ML::Rand(0.0, _Max);
    foreach(Player in Players) {
        Rand = ML__FMod(Rand + Player.Position.X +
                               Player.Position.Y +
                               Player.Position.Z, _Max);
    }
    return Rand;
}

Real SigmoidProbability(Real _X, Real _Max) {
    //https://www.wolframalpha.com/input/?i=plot+y+%3D+(100+-+100%2F(1+%2B+(x%2F(100*2%2F3))%5E6)%5E2)%2F100,+x%3D0..100
    if(_Max <= 0.000001) {
        return 1.0;
    }
    return 1 - 1 / (
                    ML::Pow(1 + ML::Pow(_X / (_Max * 2 / 3), 6.0), 2.0)
                   );
}

Void CalcAndDisplayInfChance() {
    declare Integer IMaxPoints = -1;
    declare Real    RMaxPoints = -1.0;
    declare Real    SumProb    = 0.0;

    // Find Max Score
    foreach(Player in Players) {
        if(!IsAllowedToPlay(Player))
            continue;
        if(Player.Score != Null) {
            if(IMaxPoints < Player.Score.Points)
                IMaxPoints = Player.Score.Points;
        }
    }
    RMaxPoints = ML::ToReal(IMaxPoints);

    // Calculate probabilities of being chosen
    foreach(Player in Players) {
        if(!IsAllowedToPlay(Player))
            continue;
        declare Real ProbFirstInf for Player;
        declare Real Points = 0.0;
        if(Player.Score != Null)
            Points = ML::ToReal(Player.Score.Points);
        if(!G_ProtectionQueue.exists(Player.Id)) {
            ProbFirstInf = SigmoidProbability(Points, RMaxPoints);
        } else {
            ProbFirstInf = 0.0;
        }
        SumProb += ProbFirstInf;
    }

    // Normalize probabilities and display them
    foreach(Player in Players) {
        if(!IsAllowedToPlay(Player))
            continue;
        declare Real ProbFirstInf for Player = 0.0;
        if(SumProb > 0.000001) {
            ProbFirstInf /= SumProb;
        } else {
            ProbFirstInf = 1.0 / PlayersCount();
        }

        declare DisplayDuration = EndTime - Now;
        if(DisplayDuration <= 0) {
            DisplayDuration = S_PreparationTime;
        }

        if(ProbFirstInf >= 0.01) {
            Message::SendStatusMessage(
                Player,
                TL::Compose("Your chance of being infected is $080%1%%", TL::ToText(ML::NearestInteger(ProbFirstInf * 100.0))),
                DisplayDuration,
                1
            );
        } else if(ProbFirstInf > 0.0) {
            Message::SendStatusMessage(
                Player,
                "Your chance of being infected is incredibly small",
                DisplayDuration,
                1
            );
        } else {
            Message::SendStatusMessage(
                Player,
                "You have no chance of being infected",
                DisplayDuration,
                1
            );
        }
    }
}

CSmPlayer GetFirstInfected() {
    if(CropProtectionQueue()) {
        CalcAndDisplayInfChance();
    }

    if(G_FirstInfectedId != NullId) {
        if(Players.existskey(G_FirstInfectedId)) {
            return Players[G_FirstInfectedId];
        }
        G_FirstInfectedId = NullId;
        G_PrevFirstInfectedLogin = "";
    }

    declare Real RandomNum = RealRandom(1.0);
    foreach(Player in Players) {
        if(!IsAllowedToPlay(Player))
            continue;
        declare Real ProbFirstInf for Player = 0.0;
        RandomNum -= ProbFirstInf;
        if(RandomNum <= 0.0) {
            G_FirstInfectedId = Player.Id;
            G_PrevFirstInfectedLogin = Player.User.Login;
            return Player;
        }
    }

    // This must not happen
    log(TL::Compose(C_UnexpectedBehaviour, "GetFirstInfected", "" ^ RandomNum));
    if(PlayersCount() > 0) {
        G_FirstInfectedId = Players[0].Id;
        G_PrevFirstInfectedLogin = Players[0].User.Login;
        return Players[0];
    }

    G_FirstInfectedId = NullId;
    G_PrevFirstInfectedLogin = "";
    return Null;
}

Void SetupArmor(CSmPlayer _Player, Integer _Max, Integer _Current) {
    if(_Max > 0) {
        _Player.ArmorMax = _Max * C_ArmorUnit;
    }
    if(_Current > 0) {
        _Player.Armor = _Current * C_ArmorUnit;
    }
    if(_Player.Armor > _Player.ArmorMax) {
        _Player.Armor = _Player.ArmorMax;
    }
}

Void SetupStamina(CSmPlayer _Player, Real _Gain, Real _Max) {
    if(_Gain > C_StaminaMaxGain) {
        _Player.StaminaMax = C_StaminaRealUnit;
    } else {
        _Player.StaminaMax = ML::Clamp(_Max, 0.1, 3.0);
    }
    _Player.StaminaGain = ML::Clamp(_Gain, C_StaminaMinGain, C_StaminaMaxGain);

}

Void InitSurvivor(CSmPlayer _Player) {
    _Player.ForceColor    = C_SurvivorColor;
    _Player.HasShield     = C_SurvivorHasShield;
    _Player.IsHighlighted = C_SurvivorIsHighlighted;
    _Player.EnergyLevel   = C_SurvivorEnergyLevel;

    SetupArmor(_Player, S_SurvivorMaxArmor, S_SurvivorRespawnArmor);
    SetupStamina(_Player, S_SurvivorStaminaGain, S_SurvivorStamina);
}

Void InitInfected(CSmPlayer _Player) {
    _Player.ForceColor    = C_InfectedColor;
    _Player.HasShield     = C_InfectedHasShield;
    _Player.IsHighlighted = C_InfectedIsHighlighted;
    _Player.EnergyLevel   = C_InfectedEnergyLevel;

    SetupArmor(_Player, S_InfectedMaxArmor, S_InfectedRespawnArmor);
    SetupStamina(_Player, S_InfectedStaminaGain, S_InfectedStamina);
}

Void ForceSetWeapon(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    declare Weapon = CSmMode::EWeapon::Rocket;

    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        SetPlayerAmmo(_Player, Weapon, GetPlayerAmmoMax(_Player, Weapon));
    }
    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
        SetPlayerWeapon(_Player, Weapon, True);
    }
}

Void SetupSurvivorWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    _Player.AmmoGain = S_SurvivorAmmoGain;
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_SurvivorLaserMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_SurvivorRocketMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_SurvivorNucleusMax);
    SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_SurvivorArrowMax);

    ForceSetWeapon(_Player);
}

Void SetupInfectedWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    if(!S_PursuitMode && G_InfectedPlayerCount > S_InfectedShoot) {
        _Player.AmmoGain = 0.0;
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   0);
    } else {
        _Player.AmmoGain = S_InfectedAmmoGain;
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_InfectedLaserMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_InfectedRocketMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_InfectedNucleusMax);
        SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_InfectedArrowMax);
    }

    ForceSetWeapon(_Player);
}

Void UpdateScoresStatus(CSmPlayer _Player) {
    if(!Spectators.existskey(_Player.Id)) {
        if(IsAllowedToPlay(_Player)) {
            if(IsInfected(_Player)) {
                IScores::SetStatus(_Player, IScores::Id_Status_Infected());
            } else {
                IScores::SetStatus(_Player, IScores::Id_Status_Survivor());
            }
        } else {
            IScores::SetStatus(_Player, IScores::Id_Status_KO());
        }
    } else {
        IScores::SetStatus(_Player, IScores::Id_Status_Spectator());
    }
}

Void UpdateScoresSurvivalTime(CSmPlayer _Player) {
    declare Integer SpawnTime     for _Player = -1;
    declare Integer InfectionTime for _Player = -1;
    declare SurvivalTime = -1;
    if(SpawnTime >= 0 && InfectionTime >= 0 && IsInfected(_Player)) {
        SurvivalTime = InfectionTime - SpawnTime;
    }
    IScores::SetSurvivalTime(_Player, SurvivalTime);
}

Void UpdateScores(CSmPlayer _Player) {
    UpdateScoresStatus(_Player);
    UpdateScoresSurvivalTime(_Player);
}

Void UpdateScoresTableFooter() {
    declare Text TxtFooter = "";
    if(!S_KnockoutMode) {
        if(S_RoundLimit > 0) {
            if(TxtFooter != "")
                TxtFooter ^= "   |   ";
            TxtFooter ^= _("Round") ^ " " ^ G_RoundNb ^ "/" ^ S_RoundLimit;
        }
        if(S_ScoreLimit > 0) {
            if(TxtFooter != "")
                TxtFooter ^= "   |   ";
            TxtFooter ^= "Score limit: " ^ S_ScoreLimit;
        }
    } else {
        declare Integer RoundsLeft;
        if(G_Knockout_Stage != C_Knockout_Stage_Last) {
            TxtFooter ^= "Knockout stage till " ^ S_KnockoutMode_LastStage_Players ^ " player(s) left";
            RoundsLeft = S_KnockoutMode_FirstStage_Rounds;
        } else {
            TxtFooter ^= "Max points stage";
            RoundsLeft = S_KnockoutMode_LastStage_Rounds;
        }
        TxtFooter ^= "   |   ";
        RoundsLeft -= G_Knockout_RoundNb;
        if(RoundsLeft > 1) {
            TxtFooter ^= RoundsLeft ^ " round(s) left";
        } else {
            TxtFooter ^= "Last round";
        }
    }
    IScores::SetTableFooter(TxtFooter);
}

Void UpdateModeStatusMessage() {
    ModeStatusMessage = TL::Compose(
        """Currently on the server:
-   $080%1$g infected,
-   $f00%2$g survivors, and
-   $aaa%3$g spectators.
    """,
        TL::ToText(G_InfectedPlayerCount),
        TL::ToText(PlayersCount() - G_InfectedPlayerCount),
        TL::ToText(Spectators.count)
    );
}

Void RewardInfector(CSmPlayer _Infector, Real _Score) {
    if(_Score < 1.0)
        return;
    declare Ident InfectorId for _Infector;
    if(InfectorId != NullId && Players.existskey(InfectorId)) {
        declare _Parent = Players[InfectorId];
        IScores::AddPoints(_Parent, ML::NearestInteger(_Score));
        RewardInfector(_Parent, _Score * S_RewardInfectors);
    }
}

Void RewardSurvivorsForSurvivingInfection() {
    foreach(Survivor in Players) {
        if(IsInfected(Survivor) || !IsAllowedToPlay(Survivor))
            continue;

        IScores::IncSurvivals(Survivor, S_ScoreForSurv1Inf);
    }
}

Boolean IsProtectedByMap(CSmPlayer _Player) {
    if(_Player == Null)
        return False;

    if(_Player.IsInWater) {
        if(IsInfected(_Player)) {
            return G_MapSetting_WaterForInfected_Protects;
        } else {
            return G_MapSetting_WaterForSurvivors_Protects;
        }
    }

    return False;
}

Void OnHit(CSmModeEvent _Event, Integer _PointsForHit) {
    IScores::IncHits(_Event.Shooter, _PointsForHit);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector, Text _CauseFmt, Boolean _SuppressNotifications) {
    if(_Victim == Null)
        return;

    if(IsInfected(_Victim) || (_Infector != Null && !IsInfected(_Infector))) {
        log("ERROR: Infect is called with already infected victim, or not infected infector!");
        return;
    }

    if(!IsAllowedToPlay(_Victim) || (_Infector != Null && !IsAllowedToPlay(_Infector)))
        return;

    declare netwrite Boolean Net_Infected     for _Victim;
    declare netwrite Real Net_NearestSurvivor for _Victim;

    declare Ident InfectorId for _Victim;
    declare Boolean Infected for _Victim;

    declare Integer InfectionTime for _Victim;

    declare Text InfectorLogin = "";

    Infected            = True;
    Net_Infected        = True;
    Net_NearestSurvivor = 0.0;
    if(_Infector != Null) {
        InfectorId = _Infector.Id;

        IScores::IncInfections(_Infector, S_InfectionScore);

        if(_Infector.Armor < _Infector.ArmorMax) {
            _Infector.Armor += S_InfectionArmorBonus * C_ArmorUnit;
        }
        if(S_RewardInfectors > 0) {
            RewardInfector(_Infector, S_InfectionScore * S_RewardInfectors);
        }

        InfectorLogin = _Infector.Login;
    } else {
        InfectorId = NullId;
    }

    G_InfectedPlayerCount += 1;

    if(_Victim.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        if(S_RespawnOnInfection) {
            UnspawnPlayer(_Victim);
        } else {
            InitInfected(_Victim);
            SetupInfectedWeapons(_Victim);
        }
    }

    InfectionTime = Now;
    UpdateScores(_Victim);

    RewardSurvivorsForSurvivingInfection();

    // SendNotice to all players about infection
    if(!_SuppressNotifications) {
        if(_Infector != Null) {
            foreach(Player in AllPlayers) {
                declare Text Message;
                if(Player == _Infector) {
                    Message = TL::Compose(C_TxtYouInfectedA, _Victim.Name);
                } else if (Player == _Victim) {
                    Message = TL::Compose(C_TxtAInfectedYou, _Infector.Name);
                } else {
                    Message = TL::Compose(C_TxtAInfectedB, _Infector.Name, _Victim.Name);
                }
                UIManager.GetUI(Player).SendNotice(
                    Message,
                    CUIConfig::ENoticeLevel::PlayerInfo,
                    _Infector.User,
                    CUIConfig::EAvatarVariant::Default,
                    CUIConfig::EUISound::PlayerHit,
                    0
                );
            }

            if(S_SendBigInfectionMessage > 0) {
                Message::SendStatusMessage(TL::Compose("%1$z$s infected %2$z$s!", _Infector.Name, _Victim.Name), S_SendBigInfectionMessage, 0);
            }
        } else {
            if(_CauseFmt != "") {
                UIManager.UIAll.SendNotice(
                    TL::Compose(_CauseFmt, _Victim.Name),
                    CUIConfig::ENoticeLevel::PlayerInfo,
                    _Victim.User,
                    CUIConfig::EAvatarVariant::Default,
                    CUIConfig::EUISound::PlayerHit,
                    0
                );
            }

            if(S_SendBigInfectionMessage > 0) {
                Message::SendStatusMessage(TL::Compose("%1$z$s was infected!", _Victim.Name), S_SendBigInfectionMessage, 0);
            }
        }

        if(S_SendBigInfectionMessage > 0) {
            Message::SendBigMessage(_Victim, "$360Infected!", S_SendBigInfectionMessage, 0);
        }

        // Display last survivor
        if(G_InfectedPlayerCount == PlayersCount() - 1) {
            // Get last survivor
            declare CSmPlayer LastSurvivor = Null;
            foreach(Player in Players) {
                if(!IsInfected(Player) && IsAllowedToPlay(Player)) {
                    LastSurvivor = Player;
                    break;
                }
            }
            if(LastSurvivor != Null) {
                Message::SendBigMessage(
                    TL::Compose(
                        "%1$z$s is the last survivor!",
                        LastSurvivor.Name
                    ),
                    C_LastSurvivorMsgDuration,
                    C_LastSurvivorMsgPriority
                );
            }
        }
    }

    // Update infection graph
    if(_Infector != Null) {
        ITree::Infect(_Victim.Login, _Infector.Login);
    } else {
        ITree::Infect(_Victim.Login);
    }

    XmlRpc.SendCallbackArray(C_Inf_XmlClb_Infected, [InfectorLogin, _Victim.Login]);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector, Text _CauseFmt) {
    Infect(_Victim, _Infector, _CauseFmt, False);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector) {
    Infect(_Victim, _Infector, "");
}

Void Infect(CSmPlayer _Victim) {
    Infect(_Victim, Null);
}

Void InfectByLogin(Text _Login) {
    foreach(Player in Players) {
        if(IsInfected(Player))
            continue;
        if(Player.Login == _Login) {
            Infect(Player);
            break;
        }
    }
}

Void EliminateByWater(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    UnspawnPlayer(_Player);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_TxtPlayerDrowned,
        CUIConfig::ENoticeLevel::PlayerInfo,
        _Player.User,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::PlayerHit,
        0
    );
}

Void ManageMapWaterEffectsForInfected(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForInfected_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Void ManageMapWaterEffectsForSurvivor(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForSurvivors_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForSurvivors_Infects) {
            if(!IsInfected(_Player)) {
                Infect(_Player, Null, C_TxtPlayerInfectedByWater);
            }
        }
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Boolean InfectsByDistance(Vec3 _P1, Vec3 _P2) {
    if(S_SphericalInfectionDistance <= 0.0) {
        return ML::Abs(_P1.X - _P2.X) <= S_HorizontalInfectionDistance &&
            ML::Abs(_P1.Y - _P2.Y) <= S_VerticalInfectionDistance &&
            ML::Abs(_P1.Z - _P2.Z) <= S_HorizontalInfectionDistance;
    }
    return ML::Distance(_P1, _P2) <= S_SphericalInfectionDistance;
}

Void ManageInfectedPlayer(CSmPlayer _Infected) {
    declare netwrite Net_NearestSurvivor for _Infected = 0.0;
    declare MinDetectDist = S_SurvivorDetectorMaxDist;
    foreach(Survivor in Players) {
        if(Survivor.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
            continue;
        if(IsInfected(Survivor))
            continue;
        if(InfectsByDistance(Survivor.Position, _Infected.Position)) {
            if(!IsProtectedByMap(Survivor)) {
                Infect(Survivor, _Infected);
            }
        }
        declare Real Distance = ML::Distance(Survivor.Position, _Infected.Position);
        if(Distance < MinDetectDist) {
            MinDetectDist = Distance;
        }
    }
    Net_NearestSurvivor = 1.0 - MinDetectDist / S_SurvivorDetectorMaxDist;
}

Void ManageMapLeaver(CSmPlayer _Player) {
    if(S_CanLeaveMapFor < 0) {
        return;
    }
    declare Integer LeftMapSince for _Player = -1;
    declare PlayerUI <=> UIManager.GetUI(_Player);
    if(_Player.Position.X     < 0
    || _Player.Position.Z     < 0
    || _Player.Position.X / 8 > Map.Size.X
    || _Player.Position.Z / 8 > Map.Size.Z)
    {
        if(LeftMapSince == -1) {
            LeftMapSince = Now;
        }
        if(Now - LeftMapSince < S_CanLeaveMapFor) {
            Message::SendBigMessage(_Player, C_TxtGetBackToBattleField, 1000, 2);
            Message::SendStatusMessage(
                    _Player,
                    TL::Compose(C_TxtYouWillBeInfectedInX, TL::ToText(S_CanLeaveMapFor / 1000 - ML::FloorInteger((Now - LeftMapSince) / 1000.0))),
                    1000,
                    2
                    );
        } else {
            Infect(_Player, Null, C_TxtPlayerWasEliminated);
        }
    } else if(LeftMapSince != -1) {
        LeftMapSince = -1;
    }
}

Void ManageIdlePlayer(CSmPlayer _Player) {
    if(S_ForceSpecAfter <= 0 || _Player.IdleDuration < S_ForceSpecAfter) {
        return;
    }

    if(_Player.RequestsSpectate) {
        return;
    }

    declare UI <=> UIManager.GetUI(_Player);
    if(UI == Null) {
        return;
    }

    if(UI.ForceSpectator) {
        return;
    }

    if(UI.UISequence != CUIConfig::EUISequence::Playing
    && UI.UISequence != CUIConfig::EUISequence::None) {
        return;
    }

    declare Integer SpawnTime for _Player = Now;
    if(Now - SpawnTime < S_CanIdleAfterSpawn) {
        return;
    }

    UI.ForceSpectator = True;
    Users_RequestSwitchToSpectator(_Player.User);
    UIManager.UIAll.SendChat(_Player.Name ^ C_WasIdleTooLongMovingToSpec);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_PlayerIsIdle,
        CUIConfig::ENoticeLevel::PlayerInfo,
        Null,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::Silence,
        0
    );
}

Void ConditionError(Text _Error) {
    declare Text Message = C_Cond_TxtPrefix ^ "Error: " ^ _Error;
    log(Message);
    UIManager.UIAll.SendChat(Message);
}

Boolean SetupLandmarkConditions(CSmMapLandmark _Landmark, Text _TextConditions) {
    declare Integer[][] Conditions for _Landmark;

    declare Text[] Split;
    declare Text[] SplitOR;
    declare Text[] SplitAND;

    Debug("Setting up conditions `" ^ _TextConditions ^ "` for landmark `" ^ _Landmark.Tag ^ "`");

    SplitOR = TL::Split("|", _TextConditions);
    foreach(ORConds in SplitOR) {
        SplitAND = TL::Split("&", ORConds);
        foreach(Cond in SplitAND) {
            declare Integer CCountSource = -1;
            declare Integer CComparison  = -1;
            declare Integer CValue       = -1;
            while(True) {
                Split = TL::Split("<", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_LT;
                    break;
                }
                Split = TL::Split("=", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_EQ;
                    break;
                }
                Split = TL::Split(">", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_GT;
                    break;
                }
                break;
            }
            if(CComparison == -1) {
                ConditionError("Invalid comparison `" ^ Cond ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            switch(Split[0]) {
                case C_Cond_TxtPlayers   : CCountSource = C_Cond_Players;
                case C_Cond_TxtSurvivors : CCountSource = C_Cond_Survivors;
                case C_Cond_TxtInfected  : CCountSource = C_Cond_Infected;
            }
            if(CCountSource == -1) {
                ConditionError("Invalid count source `" ^ Split[0] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            CValue = TL::ToInteger(Split[1]);
            if(CValue == -1) {
                ConditionError("Invalid value `" ^ Split[1] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            Conditions.add([CCountSource, CComparison, CValue, C_Cond_Chain_AND]);
        }
        if(Conditions.count > 0) {
            Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_OR;
        }
    }
    if(Conditions.count > 0) {
        Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_None;
    }

    Debug("Landmark `" ^ _Landmark.Tag ^ "` has " ^ Conditions.count ^ " condition(s): " ^ Conditions);

    return Conditions.count > 0;
}

Boolean SetupGateConditions(CSmMapLandmark _Gate) {
    declare Text[] Split;

    Split = TL::Split("_", _Gate.Tag);
    if(Split.count != 2) {
        return False;
    }
    if(Split[0] != "Gate") {
        return False;
    }

    Split = TL::Split(":", Split[1]);
    if(Split.count != 3) {
        Debug("Gate `" ^ _Gate.Tag ^ "` has incomplete tag! No conditions were specified");
        return False;
    }

    declare Boolean UpdateAlways  for _Gate;
    declare Boolean DefaultOpened for _Gate;

    UpdateAlways  = Split[0] == "A";
    DefaultOpened = Split[1] == "O";

    Debug("Gate `" ^ _Gate.Tag ^ "` :: UpdateAlways=" ^ UpdateAlways ^ " // DefaultOpened=" ^ DefaultOpened);

    return SetupLandmarkConditions(_Gate, Split[2]);
}

Void SetupConditionalGate(CSmMapLandmark _Gate) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    Gate.Automatic    = False;
    Gate.ManualClosed = True;
    Gate.Clan         = 0;
    Gauge.Clan        = 0;
    Gauge.Speed       = 0;
}

Void SetupCustomSpawn(CSmMapLandmark _Spawn) {
    declare Text[] Split;
    //declare Gauge <=> _Spawn.Gauge;

    Split = TL::Split("_", _Spawn.Tag);
    if(Split[0] != "Spawn") {
        return;
    }

    declare Boolean IsCommonSpawn = False;
    if(Split.count > 1) {
        Split = TL::Split(":", Split[1]);
        switch(Split[0]) {
            case C_Cond_TxtInfected:
            {
                Debug("Spawn `" ^ _Spawn.Tag ^ "` is for infected players only");
                G_InfectedSpawns.add(_Spawn);
                //Gauge.Clan = C_InfectedClanNum;
            }
            case C_Cond_TxtSurvivors:
            {
                Debug("Spawn `" ^ _Spawn.Tag ^ "` is for survivors only");
                G_SurvivorSpawns.add(_Spawn);
                //Gauge.Clan = C_SurvivorClanNum;
            }
            default: IsCommonSpawn = True;
        }
        if(Split.count > 1) {
            SetupLandmarkConditions(_Spawn, Split[1]);
        } else {
            Debug("Spawn `" ^ _Spawn.Tag ^ "` has no conditions");
        }
    } else {
        IsCommonSpawn = True;
    }
    if(IsCommonSpawn) {
        Debug("Spawn `" ^ _Spawn.Tag ^ "` is common");
        // Add to both lists, because it's common spawn
        G_InfectedSpawns.add(_Spawn);
        G_SurvivorSpawns.add(_Spawn);
        //Gauge.Clan = 0;
    }

    G_AllSpawns.add(_Spawn);
}

Void SetupMapWaterProperties(Text _TxtProperty) {
    declare Text[] Args = TL::Split("=", _TxtProperty);
    if(Args.count != 2) {
        Debug("Map water setting `" ^ _TxtProperty ^ "` is incomplete: no arguments");
        return;
    }
    switch(Args[0]) {
        case C_Cond_TxtSurvivors:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForSurvivors_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForSurvivors_Protects   = True;
                case C_MapSetting_WaterProperty_TxtInfects    : G_MapSetting_WaterForSurvivors_Infects    = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForSurvivors_Heals      = True;
            }
        }
        case C_Cond_TxtInfected:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForInfected_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForInfected_Protects   = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForInfected_Heals      = True;
            }
        }
    }
    G_MapSetting_WaterHasEffects = True;
}

Void SetupGlobalGatesProperties(Text _TxtProperty) {
    G_MapSetting_GatesCanBeClosedDuringRound = _TxtProperty == "C";
}

Void SetupMapSettings(Text _TxtSettings) {
    declare Text[] Settings = TL::Split(";", _TxtSettings);

    Debug("Setting up map settings: " ^ _TxtSettings);

    foreach(Setting in Settings) {
        declare Text[] Args = TL::Split(":", Setting);
        switch(Args[0]) {
            case C_MapSetting_Water: SetupMapWaterProperties(Args[1]);
            case C_MapSetting_Gates: SetupGlobalGatesProperties(Args[1]);
            default: Debug("Unknown map setting `" ^ Args[0] ^ "`");
        }
    }

    if(G_MapSetting_WaterHasEffects) {
        Debug("Map water settings for survivors: "
            ^ "E=" ^ G_MapSetting_WaterForSurvivors_Eliminates ^ " / "
            ^ "P=" ^ G_MapSetting_WaterForSurvivors_Protects   ^ " / "
            ^ "H=" ^ G_MapSetting_WaterForSurvivors_Heals      ^ " / "
            ^ "I=" ^ G_MapSetting_WaterForSurvivors_Infects    ^ " / "
            );
        Debug("Map water settings for infected:  "
            ^ "E=" ^ G_MapSetting_WaterForInfected_Eliminates ^ " / "
            ^ "P=" ^ G_MapSetting_WaterForInfected_Protects   ^ " / "
            ^ "H=" ^ G_MapSetting_WaterForInfected_Heals      ^ " / "
            );
    } else {
        Debug("Map water has no effects");
    }

    Debug("Conditional gates can be closed during the round: " ^ G_MapSetting_GatesCanBeClosedDuringRound);
}

Integer GetConditionalCount(Integer _Source) {
    switch(_Source) {
        case C_Cond_Players   : return PlayersCount();
        case C_Cond_Survivors : return PlayersCount() - G_InfectedPlayerCount;
        case C_Cond_Infected  : return G_InfectedPlayerCount;
    }
    return 0;
}

Boolean Compare(Integer _Count, Integer _Comparison, Integer _Value) {
    switch(_Comparison) {
        case C_Cond_Comparison_LT : return _Count < _Value;
        case C_Cond_Comparison_EQ : return _Count == _Value;
        case C_Cond_Comparison_GT : return _Count > _Value;
    }
    return False;
}

Boolean ConditionsAreSatisfied(Integer[][] _Conditions) {
    declare Boolean Result = True;
    declare Integer PrevChain = C_Cond_Chain_None;
    foreach(Condition in _Conditions) {
        declare CurrentResult = Compare(
            GetConditionalCount(Condition[C_Cond_CountSource]),
            Condition[C_Cond_Comparison],
            Condition[C_Cond_Value]
        );
        switch(PrevChain) {
            case C_Cond_Chain_AND : Result = Result && CurrentResult;
            case C_Cond_Chain_OR  : Result = Result || CurrentResult;
            case C_Cond_Chain_None: Result = CurrentResult;
            default:
            {
                // This must not happen
                log(TL::Compose(C_UnexpectedBehaviour, "ConditionsAreSatisfied", "" ^ PrevChain));
                Result = False;
            }
        }
        PrevChain = Condition[C_Cond_Chain];
    }
    return Result;
}

Void SetGateOpened(CSmMapLandmark _Gate, Boolean _Opened) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    if(_Opened) {
        Gauge.ValueReal = 0.0;
    } else {
        Gauge.ValueReal = S_ClosedCondGateValue;
    }
    Gauge.Captured = !_Opened;
    Gate.ManualClosed = !_Opened;

    if(G_IsDebugging) {
        declare Text TxtStatus;
        if(_Opened)
            TxtStatus = "opened";
        else
            TxtStatus = "closed";
        Debug("Gate " ^ _Gate.Tag ^ " has been " ^ TxtStatus);
    }
}

Void UpdateGateStatus(CSmMapLandmark _Gate, Boolean _CanClose) {
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;

    if(!_CanClose && !_Gate.Gate.ManualClosed) {
        Debug("Updating gate `" ^ _Gate.Tag ^ "` status was blocked!");
        return;
    }

    declare Status = DefaultOpened;
    if(ConditionsAreSatisfied(Conditions)) {
        // Toggle `Status` if the conditions are satisfied
        Status = !Status;
    }

    Debug("Updating gate `" ^ _Gate.Tag ^ "` status. CanClose=" ^ _CanClose ^ " / DefaultOpened=" ^ DefaultOpened ^ " / Open=" ^ Status);

    SetGateOpened(_Gate, Status);
}

CSmMapLandmark[] GetPermittedSpawns(CSmMapLandmark[] _Spawns) {
    declare CSmMapLandmark[] PermittedSpawns;
    foreach(Spawn in _Spawns) {
        declare Integer[][] Conditions for Spawn;
        if(Conditions.count > 0) {
            if(!ConditionsAreSatisfied(Conditions)) {
                Debug("Spawn `" ^ Spawn.Tag ^ "` conditions were not satisfied " ^ Conditions);
                continue;
            }
        }
        Debug("Adding spawn `" ^ Spawn.Tag ^ "` to permitted spawns");
        PermittedSpawns.add(Spawn);
    }
    return PermittedSpawns;
}

Void SpawnAndInitPlayer(CSmMapPlayerSpawn _Spawn, CSmPlayer _Player) {
    declare Boolean Infected  for _Player = False;
    declare Integer SpawnTime for _Player = -1;
    declare Integer ClanNum = 0;

    if(SpawnTime == -1) {
        SpawnTime = Now;
    }

    if(!Infected) {
        // Survivor
        InitSurvivor(_Player);
        if(S_UseClans) {
            ClanNum = C_SurvivorClanNum;
        }
    } else {
        // Infected
        InitInfected(_Player);
        if(S_UseClans) {
            ClanNum = C_InfectedClanNum;
        }
    }

    if(G_MapSetting_WaterForSurvivors_Heals || G_MapSetting_WaterForInfected_Heals) {
        // Reset ArmorReplenishGain if Player respawned in water,
        // otherwise player could get an additional armor because of
        // G_MapSetting_WaterFor..._Heals
        _Player.ArmorReplenishGain = 0;
    }

    declare UI <=> UIManager.GetUI(_Player);
    UI.ForceSpectator = False;
    SM::SpawnPlayer(_Player, ClanNum, _Player.Armor, _Spawn, SpawnTime);

    // Weapons setup
    // can be done only after spawn :(
    if(!Infected) {
        // Survivor
        SetupSurvivorWeapons(_Player);
    } else {
        // Infected
        SetupInfectedWeapons(_Player);
    }
}

Void SpawnAndInitPlayers(CSmPlayer[] _Players) {
    declare CSmMapLandmark[] SurvivorSpawns;
    declare CSmMapLandmark[] InfectedSpawns;

    Debug("Spawning and initializing players ...");

    if(IsOperating()) {
        SurvivorSpawns = GetPermittedSpawns(G_SurvivorSpawns);
        InfectedSpawns = GetPermittedSpawns(G_InfectedSpawns);
        Debug("Specific spawns will be used");
    } else {
        Debug("All spawns will be used");
    }
    foreach(Player in _Players) {
        declare CSmMapLandmark[] Spawns;
        if(IsOperating()) {

            if(G_Knockout_Stage > C_Knockout_Stage_Init) {
                // forbid respawning knocked out player
                if(!G_Knockout_Players.exists(Player.Id))
                    continue;
            }

            // New players are already infected if infection has started but have SpawnTime == -1
            // But existing players have SpawnTime != -1 if they respawn.
            declare Integer SpawnTime for Player = -1;

            if(!IsInfected(Player) && SpawnTime != -1) {
                if(C_InfectOnRespawn) {
                    if(G_InfectionStarted || S_InfectOnPreparationRespawn) {
                        Infect(Player);
                    }
                }
                if(S_SurvivorRespawnPunishment != 0) {
                    IScores::AddPoints(Player, -S_SurvivorRespawnPunishment);
                }
            }

            if(IsInfected(Player)) {
                Spawns = InfectedSpawns;
            } else {
                Spawns = SurvivorSpawns;
            }

        } else {
            Spawns = G_AllSpawns;
        }

        declare CSmMapLandmark RandomSpawn <=> Spawns[ML::Rand(0, Spawns.count - 1)];

        Debug("Spawning and initializing player `" ^ Player.Login ^ "` @ `" ^ RandomSpawn.Tag ^ "` // Infected=" ^ IsInfected(Player));

        SpawnAndInitPlayer(
            RandomSpawn.PlayerSpawn,
            Player
        );
    }
}

// Initializes and un-infects player
Void InitializePlayer(CSmPlayer _Player) {
    declare netwrite Boolean Net_Infected     for _Player;
    declare netwrite Real Net_NearestSurvivor for _Player;

    declare Ident InfectorId      for _Player;
    declare Boolean Infected      for _Player;
    declare Integer SpawnTime     for _Player;
    declare Integer InfectionTime for _Player;

    declare Integer LeftMapSince  for _Player;

    Net_Infected        = False;
    Net_NearestSurvivor = 0.0;

    InfectorId          = NullId;
    Infected            = False;
    SpawnTime           = -1;
    InfectionTime       = -1;

    LeftMapSince = -1;

    if(IsInfected(_Player)) {
        if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
            if(S_RespawnOnInfection) {
                UnspawnPlayer(_Player);
            } else {
                InitSurvivor(_Player);
                SetupSurvivorWeapons(_Player);
            }
        }
    }
}

Void OperativePlayLoop() {
    declare CSmPlayer[] UnspawnedPlayers;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            if(IsAllowedToPlay(Player))
                UnspawnedPlayers.add(Player);
            continue;
        }
        if(Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
            continue;
        }

        if(IsInfected(Player)) {
            // Infected

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForInfected(Player);
            }

            // Provide infinite stamina for infected
            if(S_InfectedStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check for infection and nearest survivor
            ManageInfectedPlayer(Player);
        } else {
            // Survivor

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForSurvivor(Player);
            }

            // Provide infinite stamina for survivor
            if(S_SurvivorStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check if leaving the map, and take some actions
            ManageMapLeaver(Player);
        }
        ManageIdlePlayer(Player);
    }

    if(UnspawnedPlayers.count > 0)
        SpawnAndInitPlayers(UnspawnedPlayers);
}

Void NonoperationalPlayLoop() {
    declare CSmPlayer[] UnspawnedPlayers;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            UnspawnedPlayers.add(Player);
            continue;
        }
    }

    if(UnspawnedPlayers.count > 0)
        SpawnAndInitPlayers(UnspawnedPlayers);
}

Void KnockoutMessage(Text _Message) {
    UIManager.UIAll.SendChat(C_Knockout_TxtPrefix ^ _Message);
}

Void KnockoutMessage(CUser _User, Text _Message) {
    declare UI <=> UIManager.GetUI(_User);
    if(UI != Null)
        UI.SendChat(C_Knockout_TxtPrefix ^ _Message);
}

Void KnockoutUser(CUser _User, Text _Reason) {
    if(S_KnockoutMode_Kick) {
        Admin_KickUser(_User, _Reason);
    } else {
        declare UI <=> UIManager.GetUI(_User);
        if(UI == Null) {
            Admin_KickUser(_User, _Reason);
        } else if(!UI.ForceSpectator) {
            UI.ForceSpectator = True;
            KnockoutMessage(_User, _Reason);
        }
    }
}

Void KnockoutEnable() {
    KnockoutMessage("Knockout mode has been enabled!");
    KnockoutInit();
    if(IsOperating()) {
        RestartGame();
    }
}

Void KnockoutDisable() {
    KnockoutMessage("Knockout mode has been disabled.");
    KnockoutInit();
    if(IsOperating()) {
        RestartGame();
    }
}

Void Pause() {
    if(G_IsPaused)
        return;
    G_IsPaused = True;

    declare Messages = TL::Split(";", S_PauseMessage);

    declare Text BigMessage    = "";
    declare Text StatusMessage = "";

    if(Messages.count > 0)
        BigMessage = Messages[0];
    if(Messages.count > 1)
        StatusMessage = Messages[1];

    Message::SetDefaultBigMessage(BigMessage);
    Message::SetDefaultStatusMessage(StatusMessage);

    EndTime = -1;

    foreach(Player in AllPlayers) {
        InitializePlayer(Player);
    }

    // Open all gates
    foreach(Gate in G_CondGates_Up_EachRound) {
        SetGateOpened(Gate, True);
    }
    foreach(Gate in G_CondGates_Up_Always) {
        SetGateOpened(Gate, True);
    }
}

Void Unpause() {
    if(!G_IsPaused)
        return;
    G_IsPaused = False;

    Message::SetDefaultBigMessage("");
    Message::SetDefaultStatusMessage("");

    if(S_PauseKeepResultsOnUnpause) {
        RestartRound();
    } else {
        RestartGame();
    }
}

Integer GetNbOfPlayersToKO() {
    declare Integer RoundsTillLastStage = S_KnockoutMode_FirstStage_Rounds - G_Knockout_RoundNb;
    if(RoundsTillLastStage <= 0)
        return 0;
    return ML::FloorInteger(ML::ToReal(PlayersCount() - S_KnockoutMode_LastStage_Players) / ML::ToReal(RoundsTillLastStage));
}

Integer[Ident] PlayersScore(Ident[] _PlayerIds) {
    declare Integer[Ident] Result;
    foreach(PlayerId in _PlayerIds) {
        if(!Players.existskey(PlayerId))
            continue;
        declare Player <=> Players[PlayerId];
        if(Player.Score == Null)
            continue;
        Result[PlayerId] = Player.Score.Points;
    }
    return Result;
}

Void InfectionXmlRpcLoop() {
    foreach(Event in XmlRpc.PendingEvents) {
        switch(Event.Type) {
            case CXmlRpcEvent::EType::Callback:
            {
                switch(Event.Param1) {
                    case C_Inf_XmlRpc_InfectByLogin:
                    {
                        InfectByLogin(Event.Param2);
                    }
                }
            }
        }
    }
}

Text GenerateManialink() {
    return """
        <frame posn="122 -82.5" id="CountsFrame">
            <label style="TextRaceMessage" posn="0 0" valign="center" halign="right" textcolor="{{{TL::ColorToText(C_InfectedColor)}}}" id="Infected"/>
            <label style="TextRaceMessage" posn="1 0" valign="center" halign="center" textcolor="fff" text="/" />
            <label style="TextRaceMessage" posn="2 0" valign="center" halign="left" textcolor="fff" id="Players"/>
        </frame>

        <label style="TextTitle1" posn="0 20" halign="center" hidden="true" textcolor="f00" id="Idle_Text">{{{C_IdlePlayerWarning}}}</label>
        <label style="TextRaceChrono" posn="0 15" halign="center" hidden="true" id="Idle_Time" />

        <frame id="NearestSurvivorFrame">
            <frame>
                <gauge posn="-21 -87" ratio="1.0" clan="{{{C_InfectedClanNum}}}" sizen="53 8" rot="180" id="NearestSurvivor" />
                <quad posn="-27 -76 10" sizen="14 14" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" />
                <quad posn="-26 -77 11" sizen="12 12" colorize="007f00" image="file:///Media/Manialinks/ShootMania/Common/MainPlayer.dds" id="SurvivorImage" />
            </frame>
            <quad posn="-0.3 0.3 0" sizen="0.6 0.6" bgcolor="fff" />
        </frame>
        <script>
        <!--
        {{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
        {{{Manialink::Animations(["EaseInOutQuad"])}}}
        main() {
            wait(InputPlayer != Null);

            declare netread Net_InfectedCount   for Teams[0] = 0;
            declare netread Net_PlayerCount     for Teams[0] = 0;
            declare netread Net_Infected        for InputPlayer = False;
            declare netread Net_NearestSurvivor for InputPlayer = 0.0;

            declare Real NearestSurvivor = 0.0;
            declare Boolean IsSpawned = False;

            declare Frame_CountsFrame     = (Page.GetFirstChild("CountsFrame")          as CMlFrame);
            declare Label_Infected        = (Page.GetFirstChild("Infected")             as CMlLabel);
            declare Label_Players         = (Page.GetFirstChild("Players")              as CMlLabel);
            declare Label_Idle_Text       = (Page.GetFirstChild("Idle_Text")            as CMlLabel);
            declare Label_Idle_Time       = (Page.GetFirstChild("Idle_Time")            as CMlLabel);
            declare Frame_NearestSurvivor = (Page.GetFirstChild("NearestSurvivorFrame") as CMlFrame);

            while(True) {
                yield;

                IsSpawned = InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned;

                if(Net_InfectedCount >= 0) {
                    if(!Frame_CountsFrame.Visible)
                        Frame_CountsFrame.Visible = True;
                    Label_Infected.Value   = TL::ToText(Net_InfectedCount);
                    Label_Players.Value    = TL::ToText(Net_PlayerCount) ^ " infected";
                } else {
                    if(Frame_CountsFrame.Visible)
                        Frame_CountsFrame.Visible = False;
                }

                if(Net_Infected && IsSpawned) {
                    if(!Frame_NearestSurvivor.Visible) {
                        Frame_NearestSurvivor.Visible = True;
                        NearestSurvivor = 1.0;
                    }
                } else {
                    Frame_NearestSurvivor.Visible = False;
                }
                if(Frame_NearestSurvivor.Visible) {
                    if(NearestSurvivor != Net_NearestSurvivor) {
                        NearestSurvivor = Net_NearestSurvivor;

                        declare Intensity = 0.5 + NearestSurvivor / 2.0;
                        LibManialink_Anim("<gauge id=\"NearestSurvivor\" ratio=\"" ^ ML::Clamp(NearestSurvivor, 0.0, 1.0) ^ "\" />", 200, "EaseInOutQuad");
                        LibManialink_Anim("<quad id=\"SurvivorImage\" colorize=\"" ^ TL::ColorToText(<0.0, Intensity, 0.0>) ^ "\" />", 200, "EaseInOutQuad");
                    } else {
                        LibManialink_AnimLoop();
                    }
                }

                if({{{S_ForceSpecAfter > 0}}}) {
                    if(IsSpawned && InputPlayer.IdleDuration >= {{{S_ForceSpecAfter * 0.8}}}) {
                        declare Integer TimeLeft = {{{S_ForceSpecAfter}}} - InputPlayer.IdleDuration;
                        Label_Idle_Text.Opacity  = 0.5 + 0.5 * ML::Sin(Now / (50.0 * ML::PI()));
                        Label_Idle_Text.Visible  = True;
                        if(TimeLeft >= 0) {
                            Label_Idle_Time.Value = TL::TimeToText(TimeLeft);
                        }
                        Label_Idle_Time.Visible = TimeLeft >= 0;
                    } else {
                        Label_Idle_Text.Visible = False;
                        Label_Idle_Time.Visible = False;
                    }
                }
            }
        }
        -->
        </script>""";
}

