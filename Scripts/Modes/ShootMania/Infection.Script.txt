#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const Version    "2017-02-22"
#Const ScriptName "Infection.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Color.Script.txt" as Color
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Scores
#Include "Libs/Nadeo/ShootMania/ScoresTable_Edit.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink

#Setting S_InfectionDistance                1.7         as "infection distance"
#Setting S_InfectionScore                   4           as "infection score"
#Setting S_InfectionArmorBonus              100         as "armor bonus for infection"
#Setting S_PVP                              False       as "enable PvP for survivors"
#Setting S_PursuitMode                      0           as "pursuit mode (0=off, 1=normal ammo, 2=inf ammo)"
#Setting S_UseClans                         True        as "use teams (need map restart)"
#Setting S_UseSameWallJump                  False       as "allow escalator jump (need round restart)"
#Setting S_HitSurvivorScore                 0           as "hit survivor score (for PvP mode)"
#Setting S_HitInfectedScore                 1           as "hit infected score"
#Setting S_ScoreForSurv1Inf                 1           as "score for surviving single infection"
#Setting S_TimeLimit                        300000      as "time limit for a round"
#Setting S_ScoreLimit                       100         as "score limit for a match"
#Setting S_RoundLimit                       0           as "round limit for a match"
#Setting S_RespawnOnInfection               True        as "respawn on infection"
#Setting S_InfectedShoot                    1           as "allow first N infected to shoot"
#Setting S_InfectedWAmmoGain                1.0         as "<hidden>"
#Setting S_InfectedWLaserMax                0           as "<hidden>"
#Setting S_InfectedWRocketMax               1           as "<hidden>"
#Setting S_InfectedWNucleusMax              0           as "<hidden>"
#Setting S_InfectedWArrowMax                0           as "<hidden>"
#Setting S_PreparationTime                  10000       as "time till first infection"
#Setting S_InfectNewPlayers                 True        as "infect new players"
#Setting S_RewardInfectors                  0.5         as "rewarding infected `parent` cooef."
#Setting S_SurvivorStamina                  1.0         as "survivor stamina (0.1-3.0)"
#Setting S_SurvivorStaminaGain              0.7         as "survivor stamina gain (0.0-1.0,10)"
#Setting S_InfectedStamina                  2.0         as "infected stamina (0.1-3.0)"
#Setting S_InfectedStaminaGain              1.0         as "infected stamina gain (0.0-1.0,10)"
#Setting S_SurvivorRespawnArmor             1           as "survivor respawn armor (1-10)"
#Setting S_SurvivorMaxArmor                 1           as "survivor maximum armor (1-10)"
#Setting S_InfectedRespawnArmor             2           as "infected respawn armor (1-10)"
#Setting S_InfectedMaxArmor                 2           as "infected maximum armor (1-10)"
#Setting S_RewardFirstInfected              0.5         as "<hidden>"
#Setting S_SurvivorDetectorMaxDist          20.0        as "survivor detector max distance"
#Setting S_RespawnDelay                     1000        as "respawn delay"
#Setting S_CanLeaveMapFor                   3000        as "can leave map for (ms)"
#Setting S_ForceSpecAfter                   60000       as "force inactive players to spectators after (ms)"
#Setting S_CanIdleAfterSpawn                10000       as "player can be idle after spawning for (ms)"

#Const   C_MinimalPlayerCount               2
#Const   C_InfectOnRespawn                  True        //as "infect on respawn"
#Const   C_InfectionTick                    30
#Const   C_SurvivorColor                    <1.0, 0.0, 0.0>
#Const   C_SurvivorHasShield                True
#Const   C_SurvivorIsHighlighted            True
#Const   C_SurvivorEnergyLevel              1.0
#Const   C_InfectedColor                    <0.0, 0.5, 0.0>
#Const   C_InfectedHasShield                True
#Const   C_InfectedIsHighlighted            False
#Const   C_InfectedEnergyLevel              1.0
#Const   C_RoundPauseTime                   4000
#Const   C_MatchPauseTime                   6000

#Const   C_MainManialinkLayer               "Infection_MainManialinkLayer"

#Const   C_SurvivorTeamId                   0
#Const   C_InfectedTeamId                   1
#Const   C_SurvivorClanNum                  1
#Const   C_InfectedClanNum                  2

#Const   C_TxtUnkTime                       "--:--.--"
#Const   C_TxtSurvivor                      "$f00Survivor"
#Const   C_TxtInfected                      "$360Infected"
#Const   C_TxtSpectator                     "$aaaSpectator"

#Const   C_TopHits                          "Hits"
#Const   C_TitleTopHits                     "Top Hits"
#Const   C_TopInfections                    "Infs"
#Const   C_TitleTopInfections               "Top Infections"
#Const   C_TopSurivals                      "Srvs"
#Const   C_TitleTopSurvivals                "Top Survivals"

#Const   C_TxtRules                         "Free for all. You spawn as a survivor, if you die you respawn infected. Infected players can't shoot, but can infect other players by touching them. The match ends when a player reaches the score limit or the round limit is reached."
#Const   C_TxtRoundEnd                      "A round ends either if no survivors are left or if the time limit is reached."
#Const   Description                        "TYPE: Free For All\nOBJECTIVE:\nSurvive as long as possible and then infect other people."

#Const   C_PlayerIsIdle                     "$z$s is idle."
#Const   C_WasIdleTooLongMovingToSpec       "$z$s was idle for too long. Moving to spectators."
#Const   C_IdlePlayerWarning                "$sYou are considered inactive!"

#Const   C_TxtYouInfectedA                  "$0f0You infected $fff%1"
#Const   C_TxtAInfectedYou                  "%1 $z$s$0f0infected you"
#Const   C_TxtAInfectedB                    "%1 $z$sinfected %2"

#Const   C_TxtAllPlayersInfected            "All players are infected!"
#Const   C_TxtTimeLimitReached              "Time limit reached!"
#Const   C_TxtNPlayersSurvivied             "$f00%1 $fffplayer(s) survived!"
#Const   C_TxtNoMoreInfected                "No more infected players!"

#Const   C_TxtGetBackToBattleField          "Get back to the battlefield!"
#Const   C_TxtYouWillBeInfectedInX          "You will be infected in $360%1"

#Const   C_LastSurvivorMsgDuration          6000
#Const   C_LastSurvivorMsgPriority          2

#Const   C_StaminaMax                       3600

#Const   C_CondGate_TxtPrefix               "$f00[CondGates] $z$s"

#Const   C_CondGateCountSource              0
#Const   C_CondGateComparison               1
#Const   C_CondGateValue                    2
#Const   C_CondGateChain                    3

#Const   C_CondGateCountSource_TxtPlayers   "P"
#Const   C_CondGateCountSource_TxtSurvivors "S"
#Const   C_CondGateCountSource_TxtInfected  "I"

#Const   C_CondGateCountSource_Players      0
#Const   C_CondGateCountSource_Survivors    1
#Const   C_CondGateCountSource_Infected     2

#Const   C_CondGateComparison_LT            0
#Const   C_CondGateComparison_EQ            1
#Const   C_CondGateComparison_GT            2

#Const   C_CondGateChain_AND                0
#Const   C_CondGateChain_OR                 1

/* -------------------------------------- */
// Globals
/* -------------------------------------- */

declare Ident   G_RoundInfoLayerId;
declare Integer G_InfectedPlayerCount;
declare Ident   G_FirstInfectedId;

declare CSmMapLandmark[] G_CondGates_Up_Always;
declare CSmMapLandmark[] G_CondGates_Up_EachRound;

declare CSmMapLandmark[] G_CommonSpawns;
declare CSmMapLandmark[] G_SurvivorSpawns;
declare CSmMapLandmark[] G_InfectedSpawns;

***InitServer***
***
UIManager.UILayerDestroyAll();
UIManager.UIAll.AltMenuNoCustomScores = True;
UIManager.UIAll.AltMenuNoDefaultScores = True;
G_RoundInfoLayerId = UIManager.UILayerCreate().Id;
***

***StartServer***
***
UsePvPCollisions = False;

SM::SetupDefaultVisibility();
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;

Color::Load(); //?

/* -------------------------------------- */
// Create the rules
declare ModeName = "Infection";
SpawnScreen::SetModeName(ModeName);
SpawnScreen::AddSubsection("Rules", C_TxtRules, 0.);
SpawnScreen::AddSubsection("Round end", C_TxtRoundEnd, 35.);
SpawnScreen::AddSubsection("Description", """- Survivors are $f00red$g, Infecteds are $360green$g.
- the first infected gets some points if all players are infected
- the first infected can shoot until there is a second infected
- when an infected player infects another player he regenerates one armor""", 60.);
SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores();
SpawnScreen::CreatePrettyRules(ModeName);

/* -------------------------------------- */
// Iniz tops
Top::Load();
Top::SetTopWidth(65.);
declare Real TopXPosition = -62.5;
declare Real TopYPosition = 42.;
declare Real TopXOffset = 65.;
declare Integer PlayersNbPerTop = 14;
declare Text TopBGImg = "file://Media/Manialinks/Shootmania/Common/topsBg.dds";
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
Top::Create(C_TopHits, C_TitleTopHits, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopInfections, C_TitleTopInfections, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopSurivals, C_TitleTopSurvivals, PlayersNbPerTop, <TopXPosition, TopYPosition>);
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
// Init scores table
ScoresTable::Load();
ScoresTable::SetTableWidth(190.);
ScoresTable::SetColumnWidth("Custom1", 10.);
ScoresTable::SetDefaultCustom1(C_TxtSurvivor);
ScoresTable::SetColumnWidth("Custom2", 7.);
ScoresTable::SetDefaultCustom2(C_TxtUnkTime);
ScoresTable::SetColumnName("Custom2", "Survival Time");
ScoresTable::SetColumnWidth("Custom3", 8.);
ScoresTable::SetDefaultCustom3("$3600$fff/$f000$fff/$ff00");
ScoresTable::SetColumnName("Custom3", "$360Inf$fff/$f00Hit$fff/$ff0Surv");
ScoresTable::SetColumnWidth("RoundPoints", 5.);
ScoresTable::SetColumnWidth("Points", 5.);
ScoresTable::SetTableFormat(2, 7);
ScoresTable::SetDefaultFooterStats("Version: " ^ Version);
ScoresTable::Build(True, False);
//Init Tabs
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer(
[
    "TopTab"    => "Buddies",
    "ScoresTab" => "Rankings"

], 30, -5, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);
ScoresTable::GetLayerScoresTable().Type = CUILayer::EUILayerType::Normal;

Layers::Create(C_MainManialinkLayer, GenerateManialink());
***

***StartMap***
***
UseClans       = S_UseClans;
UseForcedClans = S_UseClans;

// Required for manialink clan colors
Teams[C_SurvivorTeamId].ColorPrimary = C_SurvivorColor;
Teams[C_InfectedTeamId].ColorPrimary = C_InfectedColor;

UIManager.UIAll.MarkersXML = "";

G_InfectedPlayerCount = 0;
G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();

foreach(Landmark in MapLandmarks) {
    declare Tags = TL::Split("_", Landmark.Tag);
    switch(Tags[0]) {
        case "Spawn":
        {
            SetupCustomSpawn(Landmark);
        }
        case "Tornado":
        {
            if(Tags.count == 2) {
                OffZoneCenterLandmarkId = Landmark.Id;
                OffZoneRadius = TL::ToReal(Tags[1]);
            }
        }
        case "Gate":
        {
            if(SetupGateConditions(Landmark)) {
                declare Boolean UpdateAlways for Landmark = False;
                if(UpdateAlways)
                    G_CondGates_Up_Always.add(Landmark);
                else
                    G_CondGates_Up_EachRound.add(Landmark);
                SetupConditionalGate(Landmark);
            }
        }
    }
}

ScoresTable::StartMatch();
Scores::MatchBegin();

Top::ResetAll();

foreach(Player in Players) {
    declare Integer Match_Infections for Player;
    declare Integer Match_Hits       for Player;
    declare Integer Match_Survivals  for Player;

    Match_Infections = 0;
    Match_Hits       = 0;
    Match_Survivals  = 0;
}
***

***InitRound***
***
declare PrevInfectionTickTime    = 0;
declare Boolean InfectionStarted = False;

UseSameWallJump = S_UseSameWallJump;
UsePvPWeapons = (S_PursuitMode == 0);

MB_UseSectionRound = True;
***


***StartRound***
***
Scores::RoundBegin();
UIManager.UIAll.UISequence      = CUIConfig::EUISequence::Playing;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Default;

G_InfectedPlayerCount = 0;

foreach(Player in AllPlayers) {
    declare Integer Round_Infections for Player;
    declare Integer Round_Hits       for Player;
    declare Integer Round_Survivals  for Player;

    Round_Infections = 0;
    Round_Hits       = 0;
    Round_Survivals  = 0;
}

UpdateModeStatusMessage();

StartTime = Now + 1000;
EndTime   = Now + 1000 + S_PreparationTime;

UIManager.UIAll.UILayers.add(UIManager.UILayers[G_RoundInfoLayerId]);

// Update conditional gates
foreach(Gate in G_CondGates_Up_EachRound) {
    UpdateGateStatus(Gate);
}
***


***InitTurn***
***
MB_UseSectionTurn = False;
***

***OnNewPlayer***
***
declare netwrite Boolean Net_Infected     for Player;
declare netwrite Real Net_NearestSurvivor for Player;

declare Ident InfectorId      for Player = NullId;
declare Boolean Infected      for Player;
declare Integer SpawnTime     for Player = -1;
declare Integer InfectionTime for Player = -1;

Infected            = InfectionStarted && S_InfectNewPlayers;
Net_Infected        = Infected;
Net_NearestSurvivor = 0.0;

UpdateTable(Player);

ScoresTable::RestoreCustomScores(Player);
declare UI <=> UIManager.GetUI(Player);
Tabs::UseTabs(UI, "ScoresTab");
Tabs::AlwaysShowScore(UI, True);

if(Layers::IsMissing(C_MainManialinkLayer, Player.Id)) {
    Layers::Attach(C_MainManialinkLayer, Player.Id);
}
***

***OnNewSpectator***
***
UpdateTable(Spectator);

ScoresTable::RestoreCustomScores(Spectator);

declare UI <=> UIManager.GetUI(Spectator);
Tabs::UseTabs(UI, "ScoresTab");
Tabs::AlwaysShowScore(UI, True);

if(UI != Null) {
    UI.SpectatorForcedClan      = 0;
    UI.SpectatorForceCameraType = 15;
}

if(Layers::IsMissing(C_MainManialinkLayer, Spectator.Id)) {
    Layers::Attach(C_MainManialinkLayer, Spectator.Id);
}
***

***PlayLoop***
***
declare netwrite Integer Net_PlayerCount   for Teams[0];
declare netwrite Integer Net_InfectedCount for Teams[0];

declare Integer Prev_PlayerCount for This         = -1;
declare Integer Prev_InfectedPlayerCount for This = -1;

// Cannot be done more efficiently as there's no event "player left"
if(Prev_PlayerCount != Players.count) {
    if(Prev_PlayerCount < C_MinimalPlayerCount && Players.count >= C_MinimalPlayerCount) {
        // If it's enough players now, restart round!
        MB_StopRound();
    } else if(Prev_PlayerCount >= C_MinimalPlayerCount && Players.count < C_MinimalPlayerCount) {
        // If it's not enough players now, restart round and display message!
        MB_StopRound();
    }

    Prev_PlayerCount      = Players.count;
    Net_PlayerCount       = Prev_PlayerCount;

    G_InfectedPlayerCount    = CountInfected();
    Prev_InfectedPlayerCount = G_InfectedPlayerCount;
    Net_InfectedCount        = G_InfectedPlayerCount;

    foreach(Gate in G_CondGates_Up_Always) {
        UpdateGateStatus(Gate);
    }
}
// This can be out of sync because of `Infect`, `OnNewPlayer`, `OnNewSpectator`
if(Prev_InfectedPlayerCount != G_InfectedPlayerCount) {
    Prev_InfectedPlayerCount = G_InfectedPlayerCount;
    Net_InfectedCount = G_InfectedPlayerCount;

    foreach(Gate in G_CondGates_Up_Always) {
        UpdateGateStatus(Gate);
    }
}

if(PrevInfectionTickTime + C_InfectionTick < Now) {
    PrevInfectionTickTime = Now;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            declare Integer SpawnTime for Player = -1;
            if(C_InfectOnRespawn && SpawnTime != -1 && !IsInfected(Player)) {
                // If not a new player has respawned, infect him
                Infect(Player, Null);
            }
            SpawnAndInitPlayer(Player);
            continue;
        }
        if(Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
            continue;
        }

        if(IsInfected(Player)) {
            // Infected

            // Provide infinite stamina for infected
            if(S_InfectedStaminaGain > 1.0) {
                Player.Stamina = C_StaminaMax;
            }

            // Check for infection and nearest survivor
            ManageInfectedPlayer(Player);
        } else {
            // Survivor

            // Provide infinite stamina for survivor
            if(S_SurvivorStaminaGain > 1.0) {
                Player.Stamina = C_StaminaMax;
            }

            // Check if leaving the map, and take some actions
            ManageMapLeaver(Player);
        }
        ManageIdlePlayer(Player);
    }

    Message::Loop();
    Top::Loop();
}

if(EndTime > -1 && EndTime <= Now) {
    if(!InfectionStarted) {
        // Begin infection round
        InfectionStarted = True;

        if(S_TimeLimit > 0) {
            EndTime = Now + S_TimeLimit;
        } else {
            EndTime = -1;
        }

        if(Players.count >= C_MinimalPlayerCount) {
            declare FirstInfected = GetFirstInfected();
            if(FirstInfected != Null) {
                Infect(FirstInfected, Null);

                Message::SendStatusMessage("$iLet the infection begin...", 4000, 1);
                Message::SendBigMessage(FirstInfected, "$360First Infected!", 4000, 1);
                foreach(Survivor in AllPlayers) {
                    if(IsInfected(Survivor))
                        continue;

                    Message::SendBigMessage(Survivor, FirstInfected.Name ^ "$z$s$360 is the first infected!", 4000, 1);
                }
            } else {
                // This must not happen
                log("First infected left immediately, this must not happen!");
                MB_StopRound();
            }
        } else {
            // Not enough players
            UIManager.UIAll.BigMessage    = "$f92Waiting for Players";
            UIManager.UIAll.StatusMessage = TL::Compose("At least $f00%1 $fffplayers are needed!", TL::ToText(C_MinimalPlayerCount));
        }
    } else {
        // End infection round
        MB_StopRound();
    }
}

if((InfectionStarted && G_InfectedPlayerCount == 0) || (G_InfectedPlayerCount >= Players.count)) {
    // Don't end the round if not enough players
    if(Players.count >= C_MinimalPlayerCount) {
        MB_StopRound();
    }
}

foreach(Event in PendingEvents) {
    switch(Event.Type) {
        case CSmModeEvent::EType::OnHit:
        {
            if(Event.Shooter == Event.Victim) {
                Discard(Event);
                continue;
            }
            declare ShooterInfected = IsInfected(Event.Shooter);
            declare VictimInfected  = IsInfected(Event.Victim);
            if(VictimInfected && !ShooterInfected) {
                // OnSurvivorHitInfected
                if(S_HitInfectedScore != 0) {
                    OnHit(Event, S_HitInfectedScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && !ShooterInfected) {
                // OnSurvivorHitSurvivor
                if(S_PVP && S_HitSurvivorScore != 0) {
                    OnHit(Event, S_HitSurvivorScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && ShooterInfected) {
                // OnInfectedHitSurvivor
                Infect(Event.Victim, Event.Shooter);
                Discard(Event);
            } else {
                // OnInfectedHitInfected
                Discard(Event);
            }
        }
        case CSmModeEvent::EType::OnCommand:
            //TODO:???
            /*switch (Event.CommandName)
            {
                case "Infect":
                {
                    if (Event.CommandValueInteger > 0)
                    {
                        for (I, 1, Event.CommandValueInteger)
                        {
                            InfectRandomSurvivor();
                        }
                    }
                }
            }*/
            Discard(Event);
        // case CSmModeEvent::EType::OnPlayerRequestRespawn:
        //     PassOn(Event);
        default:
            PassOn(Event);
    }
}

***

***EndRound***
***
Top::Loop();
Scores::RoundEnd();

StartTime = -1;
EndTime   = -1;

if(S_RewardFirstInfected > 0.0 && Players.existskey(G_FirstInfectedId)) {
    declare FirstInfected <=> Players[G_FirstInfectedId];
    Scores::AddPoints(FirstInfected, ML::NearestInteger(G_InfectedPlayerCount * S_RewardFirstInfected));
}

// Clean UI
Message::CleanAllMessages();

// Display result
UIManager.UIAll.UILayers.removekey(G_RoundInfoLayerId);
UIManager.UIAll.UISequence           = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound      = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.StatusMessage        = "";

if(G_InfectedPlayerCount >= Players.count) {
    UIManager.UIAll.BigMessage = C_TxtAllPlayersInfected;
} else if(G_InfectedPlayerCount == 0) {
    UIManager.UIAll.BigMessage = C_TxtNoMoreInfected;
    MB_SectionRoundNb -= 1;
} else {
    UIManager.UIAll.BigMessage    = C_TxtTimeLimitReached;
    UIManager.UIAll.StatusMessage = TL::Compose(C_TxtNPlayersSurvivied, TL::ToText(Players.count - G_InfectedPlayerCount));
}

// Check for limits
if(S_ScoreLimit > 0) {
    foreach(Player in Players) {
        if(Player.Score != Null && Player.Score.Points >= S_ScoreLimit) {
            MB_StopMap();
            break;
        }
    }
}

if(S_RoundLimit > 0 && MB_SectionRoundNb >= S_RoundLimit) {
    MB_StopMap();
}

sleep(C_RoundPauseTime);

UIManager.UIAll.StatusMessage        = "";
UIManager.UIAll.BigMessage           = "";
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

SM::UnspawnAllPlayers();
DestroyAllBotPlayers();
***

***EndMap***
***
// UseClans = False;
// UseForcedClans = False;
/* -------------------------------------- */
// Update map scores
ScoresTable::EndMatch();
Scores::MatchEnd();
UIManager.UIAll.BigMessage      = "";
UIManager.UIAll.StatusMessage   = "";
declare CSmPlayer[] MaxScores;
declare Integer MaxScore = 0;

foreach (Player in Players)
{
    if (Player.Score != Null)
    {
        if (MaxScore < Player.Score.Points)
        {
            MaxScores.clear();
            MaxScores.add(Player);
            MaxScore = Player.Score.Points;
        }
        else if (MaxScore == Player.Score.Points)
        {
            MaxScores.add(Player);
        }
    }
}

foreach(Player in AllPlayers) {
    Layers::Detach(C_MainManialinkLayer, Player.Id);
}

if (MaxScore == 0)
{
    UIManager.UIAll.BigMessage = _("|Match|Draw");
}
else
{
    declare Text PlayerNames = MaxScores[0].Name;

    if (MaxScores.count > 1)
    {
        for (I, 1, MaxScores.count - 1)
        {
            if (I < MaxScores.count - 1)
            {
                PlayerNames ^= ", " ^ MaxScores[I].Name;
            }
            else
            {
                PlayerNames ^= "and " ^ MaxScores[I].Name;
            }
        }
    }

    UIManager.UIAll.BigMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
}

sleep(2000);
/* -------------------------------------- */
// Display result
UIManager.UIAll.UISequence              = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound         = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence              = CUIConfig::EUISequence::Podium;
sleep(C_MatchPauseTime - 2000);
UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage              = "";

G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
OffZoneCenterLandmarkId = NullId;
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();
***

***EndServer***
***
/* -------------------------------------- */
// Clean the UI
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
UIManager.ResetAll();
UIManager.UILayerDestroyAll();

/* -------------------------------------- */
// Stop the library
Color::Unload();
ScoresTable::Unload();
***

Boolean IsInfected(CSmPlayer _Player) {
    if(_Player != Null) {
        declare Infected for _Player = S_InfectNewPlayers;
        return Infected;
    }
    return False;
}

Integer CountInfected() {
    declare Integer Count = 0;
    foreach(Player in Players) {
        if(IsInfected(Player))
            Count += 1;
    }
    return Count;
}

Real ML__FMod(Real _Value, Real _Mod) {
    return _Value - ML::ToReal(ML::FloorInteger(_Value / _Mod)) * _Mod;
}

Real RealRandom(Real _Max) {
    declare Real Rand = ML::Rand(0.0, _Max);
    foreach(Player in Players) {
        Rand = ML__FMod(Rand + Player.Position.X +
                               Player.Position.Y +
                               Player.Position.Z, _Max);
    }
    return Rand;
}

Real SigmoidProbability(Real _X, Real _Max) {
    //https://www.wolframalpha.com/input/?i=plot+y+%3D+(100+-+100%2F(1+%2B+(x%2F(100*2%2F3))%5E6)%5E2)%2F100,+x%3D0..100
    if(_Max <= 0.000001) {
        return 1.0;
    }
    return 1 - 1 / (
                    ML::Pow(1 + ML::Pow(_X / (_Max * 2 / 3), 6.0), 2.0)
                   );
}

CSmPlayer GetFirstInfected() {
    if(G_FirstInfectedId != NullId) {
        if(Players.existskey(G_FirstInfectedId)) {
            return Players[G_FirstInfectedId];
        }
        G_FirstInfectedId = NullId;
    }

    declare Integer IMaxPoints = -1;
    declare Real    RMaxPoints = -1.0;
    declare Real    SumProb    = 0.0;
    declare Real    RandomNum;

    // Find Max Score
    foreach(Player in Players) {
        if(Player.Score != Null) {
            if(IMaxPoints < Player.Score.Points)
                IMaxPoints = Player.Score.Points;
        }
    }
    RMaxPoints = ML::ToReal(IMaxPoints);

    // Calculate probabilities of being chosen
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player;
        declare Real Points = 0.0;
        if(Player.Score != Null)
            Points = ML::ToReal(Player.Score.Points);
        ProbFirstInf = SigmoidProbability(Points, RMaxPoints);
        SumProb += ProbFirstInf;
    }

    RandomNum = RealRandom(SumProb);
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player = 0.0;
        RandomNum -= ProbFirstInf;
        if(RandomNum <= 0.0) {
            G_FirstInfectedId = Player.Id;
            return Player;
        }
    }

    log("this must not happen! No random player was chosen!");
    if(Players.count > 0) {
        log("choosing first one");
        G_FirstInfectedId = Players[0].Id;
        return Players[0];
    }

    G_FirstInfectedId = NullId;
    return Null;
}

CSmMapPlayerSpawn GetRandomSurvivorSpawn() {
    return G_SurvivorSpawns[ML::Rand(0, G_SurvivorSpawns.count - 1)].PlayerSpawn;
}

CSmMapPlayerSpawn GetRandomInfectedSpawn() {
    return G_InfectedSpawns[ML::Rand(0, G_InfectedSpawns.count - 1)].PlayerSpawn;
}

Void InitSurvivor(CSmPlayer _Player) {
    _Player.ForceColor    = C_SurvivorColor;
    _Player.HasShield     = C_SurvivorHasShield;
    _Player.IsHighlighted = C_SurvivorIsHighlighted;
    _Player.EnergyLevel   = C_SurvivorEnergyLevel;

    // Setup armor
    if(S_SurvivorMaxArmor > 0) {
        _Player.ArmorMax = S_SurvivorMaxArmor * 100;
    }
    if(S_SurvivorRespawnArmor > 0) {
        _Player.Armor = S_SurvivorRespawnArmor * 100;
    }
    if(_Player.Armor > _Player.ArmorMax) {
        _Player.Armor = _Player.ArmorMax;
    }

    // Setup stamina
    if(S_SurvivorStamina >= 0.1 && S_SurvivorStamina <= 3.0) {
        _Player.StaminaMax = S_SurvivorStamina;
    } else {
        _Player.StaminaMax = 1.0;
    }
    if(S_SurvivorStaminaGain >= 0.0 && S_SurvivorStaminaGain <= 1.0) {
        _Player.StaminaGain = S_SurvivorStaminaGain;
    } else {
        _Player.StaminaGain = 1.0;
    }
}

Void InitInfected(CSmPlayer _Player) {
    _Player.ForceColor    = C_InfectedColor;
    _Player.HasShield     = C_InfectedHasShield;
    _Player.IsHighlighted = C_InfectedIsHighlighted;
    _Player.EnergyLevel   = C_InfectedEnergyLevel;

    // Setup armor
    if(S_InfectedMaxArmor > 0) {
        _Player.ArmorMax = S_InfectedMaxArmor * 100;
    }
    if(S_InfectedRespawnArmor > 0) {
        _Player.Armor = S_InfectedRespawnArmor * 100;
    }
    if(_Player.Armor > _Player.ArmorMax) {
        _Player.Armor = _Player.ArmorMax;
    }

    // Setup stamina
    if(S_InfectedStamina >= 0.1 && S_InfectedStamina <= 3.0) {
        _Player.StaminaMax = S_InfectedStamina;
    } else {
        _Player.StaminaMax = 1.0;
    }
    if(S_InfectedStaminaGain >= 0.0 && S_InfectedStaminaGain <= 1.0) {
        _Player.StaminaGain = S_InfectedStaminaGain;
    } else {
        _Player.StaminaGain = 1.0;
    }
}

Void SetupSurvivorWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    switch(S_PursuitMode) {
        case 0:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   2);
        }
        case 1:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   3);
        }
        case 2:
        {
            _Player.AmmoGain = 10.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   10);
        }
    }

    SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket));
    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
        SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
    }
}

Void SetupInfectedWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    switch(S_PursuitMode) {
        case 0:
        {
            _Player.AmmoGain = 0.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   0);
            // Override default settings
            if(G_InfectedPlayerCount <= S_InfectedShoot) {
                _Player.AmmoGain = S_InfectedWAmmoGain;
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_InfectedWLaserMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_InfectedWRocketMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_InfectedWNucleusMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_InfectedWArrowMax);
            }
        }
        case 1:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   3);
        }
        case 2:
        {
            _Player.AmmoGain = 10.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   10);
        }
    }

    SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket));
    if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
        SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
    }
}

Void SpawnAndInitPlayer(CSmPlayer _Player) {
    declare Boolean Infected  for _Player = False;
    declare Integer SpawnTime for _Player = -1;
    declare Integer ClanNum = 0;
    declare CSmMapPlayerSpawn PlayerSpawn;

    if(SpawnTime == -1) {
        SpawnTime = Now + S_RespawnDelay;
    }

    if(!Infected) {
        // Survivor
        InitSurvivor(_Player);
        if(S_UseClans) {
            ClanNum = C_SurvivorClanNum;
        }
        PlayerSpawn <=> GetRandomSurvivorSpawn();
    } else {
        // Infected
        InitInfected(_Player);
        if(S_UseClans) {
            ClanNum = C_InfectedClanNum;
        }
        PlayerSpawn <=> GetRandomInfectedSpawn();
    }

    SM::SpawnPlayer(_Player, ClanNum, _Player.Armor, PlayerSpawn, SpawnTime);

    // Weapons setup
    // can be done only after spawn :(
    if(!Infected) {
        // Survivor
        SetupSurvivorWeapons(_Player);
    } else {
        // Infected
        SetupInfectedWeapons(_Player);
    }
}

Void UpdateTable(CSmPlayer _Player) {
    UpdateTablePlayerStatus(_Player);
    UpdateTableSurvivalTime(_Player);
    UpdateTableScores(_Player);
}

Void UpdateTablePlayerStatus(CSmPlayer _Player) {
    if(!Spectators.existskey(_Player.Id)) {
        if(IsInfected(_Player)) {
            ScoresTable::SetCustom1(Spectator, C_TxtInfected);
        } else {
            ScoresTable::SetCustom1(Spectator, C_TxtSurvivor);
        }
    } else {
        ScoresTable::SetCustom1(Spectator, C_TxtSpectator);
    }
}

Void UpdateTableSurvivalTime(CSmPlayer _Player) {
    declare Integer SpawnTime     for _Player = -1;
    declare Integer InfectionTime for _Player = -1;
    if(IsInfected(_Player)) {
        declare SurvivalTime = InfectionTime - SpawnTime;
        if(SurvivalTime < 0) {
            SurvivalTime = 0;
        }
        ScoresTable::SetCustom2(_Player, TL::TimeToText(SurvivalTime, True));
    } else {
        ScoresTable::SetCustom2(_Player, C_TxtUnkTime);
    }
}

Void UpdateTableScores(CSmPlayer _Player) {
    declare Round_Infections for _Player = 0;
    declare Round_Hits       for _Player = 0;
    declare Round_Survivals  for _Player = 0;

    ScoresTable::SetCustom3(_Player,
        TL::Compose("$360%1$fff/$f00%2$fff/$ff0%3",
            TL::ToText(Round_Infections),
            TL::ToText(Round_Hits),
            TL::ToText(Round_Survivals)
        )
    );
}

Void UpdateModeStatusMessage() {
    ModeStatusMessage = TL::Compose(
        """Currently on the server:
-   $360%1$g infected,
-   $f00%2$g survivors, and
-   $aaa%3$g spectators.
    """,
        TL::ToText(G_InfectedPlayerCount),
        TL::ToText(Players.count - G_InfectedPlayerCount),
        TL::ToText(Spectators.count)
    );
}

Void RewardInfector(CSmPlayer _Infector, Real _Score) {
    if(_Score < 1.0)
        return;
    declare Ident InfectorId for _Infector;
    if(InfectorId != NullId && Players.existskey(InfectorId)) {
        declare _Parent = Players[InfectorId];
        Scores::AddPoints(_Parent, ML::NearestInteger(_Score));
        RewardInfector(_Parent, _Score * S_RewardInfectors);
    }
}

Void RewardSurvivorsForSurvivingInfection() {
    foreach(Survivor in Players) {
        if(IsInfected(Survivor))
            continue;

        declare Round_Survivals for Survivor = 0;
        declare Match_Survivals for Survivor = 0;
        Round_Survivals += 1;
        Match_Survivals += 1;
        Top::SetRecord(Survivor, C_TopSurivals, TL::ToText(Match_Survivals), -Match_Survivals);
        Scores::AddPoints(Survivor, S_ScoreForSurv1Inf);
        UpdateTableScores(Survivor);
    }
}

Void OnHit(CSmModeEvent _Event, Integer _Multiplier) {
    declare Match_Hits for _Event.Shooter = 0;
    declare Round_Hits for _Event.Shooter = 0;
    declare Integer Points = _Event.Damage / 100 * _Multiplier;
    Round_Hits += Points;
    Match_Hits += Points;
    Scores::AddPoints(_Event.Shooter, Points);
    Top::SetRecord(_Event.Shooter, C_TopHits, TL::ToText(Match_Hits), -Match_Hits);
    UpdateTableScores(_Event.Shooter);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector) {
    if(_Victim == Null)
        return;

    if(IsInfected(_Victim) || (_Infector != Null && !IsInfected(_Infector))) {
        log("ERROR: Infect is called with already infected victim, or not infected infector!");
        return;
    }

    declare netwrite Boolean Net_Infected     for _Victim;
    declare netwrite Real Net_NearestSurvivor for _Victim;

    declare Ident InfectorId  for _Victim;
    declare Boolean Infected  for _Victim = S_InfectNewPlayers;

    declare Integer SpawnTime     for _Victim;
    declare Integer InfectionTime for _Victim;

    Infected            = True;
    Net_Infected        = True;
    Net_NearestSurvivor = 0.0;
    if(_Infector != Null) {
        InfectorId = _Infector.Id;

        declare Match_Infections for _Infector = 0;
        declare Round_Infections for _Infector = 0;
        Round_Infections += 1;
        Match_Infections += 1;
        Top::SetRecord(_Infector, C_TopInfections, TL::ToText(Match_Infections), -Match_Infections);

        if(_Infector.Armor < _Infector.ArmorMax) {
            _Infector.Armor += S_InfectionArmorBonus;
        }
        if(S_RewardInfectors > 0) {
            RewardInfector(_Infector, S_InfectionScore * S_RewardInfectors);
        }

        Scores::AddPoints(_Infector, S_InfectionScore);
        UpdateTableScores(_Infector);

        ScoresTable::SetFooterStats(_Victim, "Infected by: " ^ _Infector.Name);

        // Notify everyone about infection
        //Message::SendStatusMessage(TL::Compose("%1$z$s infected %2$z$s!", _Infector.Name, _Victim.Name), 4000, 1);
        //Message::SendBigMessage(_Victim, "$360Infected!", 4000, 1);
    }

    G_InfectedPlayerCount += 1;
    if(G_InfectedPlayerCount > S_InfectedShoot) {
        // Re-setup infector weapons
        foreach(Infected in Players) {
            if(!IsInfected(Infected)) {
                continue;
            }
            SetupInfectedWeapons(Infected);
        }
    }

    if(_Victim.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        if(S_RespawnOnInfection) {
            UnspawnPlayer(_Victim);
        } else {
            InitInfected(_Victim);
            SetupInfectedWeapons(_Victim);
        }
    }

    InfectionTime = Now;
    UpdateTablePlayerStatus(_Victim);
    UpdateTableSurvivalTime(_Victim);

    RewardSurvivorsForSurvivingInfection();

    // SendNotice to all players about infection
    if(_Infector != Null) {
        foreach(Player in AllPlayers) {
            declare Text Message;
            if(Player == _Infector) {
                Message = TL::Compose(C_TxtYouInfectedA, _Victim.Name);
            } else if (Player == _Victim) {
                Message = TL::Compose(C_TxtAInfectedYou, _Infector.Name);
            } else {
                Message = TL::Compose(C_TxtAInfectedB, _Infector.Name, _Victim.Name);
            }
            UIManager.GetUI(Player).SendNotice(
                Message,
                CUIConfig::ENoticeLevel::PlayerInfo,
                _Infector.User,
                CUIConfig::EAvatarVariant::Default,
                CUIConfig::EUISound::PlayerHit,
                0
            );
        }
    }

    if(G_InfectedPlayerCount == Players.count - 1) {
        // Get last survivor
        declare CSmPlayer LastSurvivor = Null;
        foreach(Player in Players) {
            if(!IsInfected(Player)) {
                LastSurvivor = Player;
                break;
            }
        }
        if(LastSurvivor != Null) {
            Message::SendBigMessage(
                TL::Compose(
                    "%1$z$s is the last survivor!",
                    LastSurvivor.Name
                ),
                C_LastSurvivorMsgDuration,
                C_LastSurvivorMsgPriority
            );
        }
    }

    UpdateModeStatusMessage();
}

Void ManageInfectedPlayer(CSmPlayer _Infected) {
    declare netwrite Net_NearestSurvivor for _Infected = 0.0;
    declare MinDetectDist = S_SurvivorDetectorMaxDist;
    foreach(Survivor in Players) {
        if(Survivor.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
            continue;
        if(IsInfected(Survivor))
            continue;
        declare Real Distance = ML::Distance(Survivor.Position, _Infected.Position);
        if(Distance < S_InfectionDistance) {
            Infect(Survivor, _Infected);
        }
        if(Distance < MinDetectDist) {
            MinDetectDist = Distance;
        }
    }
    Net_NearestSurvivor = 1.0 - MinDetectDist / S_SurvivorDetectorMaxDist;
}

Void ManageMapLeaver(CSmPlayer _Player) {
    if(S_CanLeaveMapFor < 0) {
        return;
    }
    declare Integer LeftMapSince for _Player = -1;
    declare PlayerUI <=> UIManager.GetUI(_Player);
    if(_Player.Position.X     < 0
    || _Player.Position.Z     < 0
    || _Player.Position.X / 8 > Map.Size.X
    || _Player.Position.Z / 8 > Map.Size.Z)
    {
        if(LeftMapSince == -1) {
            LeftMapSince = Now;
        }
        if(Now - LeftMapSince < S_CanLeaveMapFor) {
            PlayerUI.BigMessage    = C_TxtGetBackToBattleField;
            PlayerUI.StatusMessage = TL::Compose(C_TxtYouWillBeInfectedInX, TL::ToText(S_CanLeaveMapFor / 1000 - ML::FloorInteger((Now - LeftMapSince) / 1000.0)));
        } else {
            Infect(_Player, Null);
        }
    } else if(LeftMapSince != -1) {
        LeftMapSince = -1;
        PlayerUI.BigMessage    = "";
        PlayerUI.StatusMessage = "";
    }
}

Void ManageIdlePlayer(CSmPlayer _Player) {
    if(S_ForceSpecAfter <= 0) {
        return;
    }

    if(_Player.IdleDuration < S_ForceSpecAfter) {
        return;
    }

    declare Integer SpawnTime for _Player = Now;
    if(Now - SpawnTime < S_CanIdleAfterSpawn) {
        return;
    }

    Users_RequestSwitchToSpectator(_Player.User);
    UIManager.UIAll.SendChat(_Player.Name ^ C_WasIdleTooLongMovingToSpec);
    UIManager.UIAll.SendNotice(
        C_PlayerIsIdle,
        CUIConfig::ENoticeLevel::PlayerInfo,
        Null,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::Silence,
        0
    );
}

Void SetupCustomSpawn(CSmMapLandmark _Spawn) {
    declare Tags = TL::Split("_", _Spawn.Tag);
    //declare Gauge <=> _Spawn.Gauge;

    declare Boolean IsCommonSpawn = False;
    if(Tags.count == 2) {
        switch(Tags[1]) {
            case "Infected":
            {
                G_InfectedSpawns.add(_Spawn);
                //Gauge.Clan = C_InfectedClanNum;
            }
            case "Survivor":
            {
                G_SurvivorSpawns.add(_Spawn);
                //Gauge.Clan = C_SurvivorClanNum;
            }
            default: IsCommonSpawn = True;
        }
    } else {
        IsCommonSpawn = True;
    }
    if(IsCommonSpawn) {
        // Add to both lists, because it's common spawn
        G_InfectedSpawns.add(_Spawn);
        G_SurvivorSpawns.add(_Spawn);
        //Gauge.Clan = 0;
    }
}

Void CondGateWarning(Text _Warning) {
    declare Text Message = C_CondGate_TxtPrefix ^ "Warning: " ^ _Warning;
    log(Message);
    UIManager.UIAll.SendChat(Message);
}

Boolean SetupGateConditions(CSmMapLandmark _Gate) {
    declare Text[] Split;
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;
    declare Boolean UpdateAlways   for _Gate = False;

    Split = TL::Split("_", _Gate.Tag);
    if(Split.count != 2) {
        return False;
    }
    if(Split[0] != "Gate") {
        return False;
    }

    Split = TL::Split(":", Split[1]);
    if(Split.count != 3) {
        return False;
    }

    UpdateAlways  = Split[0] == "A";
    DefaultOpened = Split[1] == "O";

    declare Text[] SplitOR = TL::Split("|", Split[2]);
    foreach(ORConds in SplitOR) {
        declare Text[] SplitAND = TL::Split("&", ORConds);
        foreach(Cond in SplitAND) {
            declare Integer CCountSource = -1;
            declare Integer CComparison  = -1;
            declare Integer CValue       = -1;
            while(True) {
                Split = TL::Split("<", Cond);
                if(Split.count == 2) {
                    CComparison = C_CondGateComparison_LT;
                    break;
                }
                Split = TL::Split("=", Cond);
                if(Split.count == 2) {
                    CComparison = C_CondGateComparison_EQ;
                    break;
                }
                Split = TL::Split(">", Cond);
                if(Split.count == 2) {
                    CComparison = C_CondGateComparison_GT;
                    break;
                }
                break;
            }
            if(CComparison == -1) {
                CondGateWarning("Invalid comparison `" ^ Cond ^ "` in conditional gate: " ^ _Gate.Tag);
                continue;
            }
            switch(Split[0]) {
                case C_CondGateCountSource_TxtPlayers   : CCountSource = C_CondGateCountSource_Players;
                case C_CondGateCountSource_TxtSurvivors : CCountSource = C_CondGateCountSource_Survivors;
                case C_CondGateCountSource_TxtInfected  : CCountSource = C_CondGateCountSource_Infected;
            }
            if(CCountSource == -1) {
                CondGateWarning("Invalid count source `" ^ Split[0] ^ "` in conditional gate: " ^ _Gate.Tag);
                continue;
            }
            if(!UpdateAlways && (CCountSource == C_CondGateCountSource_Survivors || CCountSource == C_CondGateCountSource_Infected)) {
                CondGateWarning("condition dependednt on count source `" ^ Split[0] ^ "` makes no sense if updating only on round start! Gate: " ^ _Gate.Tag);
            }
            CValue = TL::ToInteger(Split[1]);
            if(CValue == -1) {
                CondGateWarning("Invalid value `" ^ Split[1] ^ "` in conditional gate: " ^ _Gate.Tag);
                continue;
            }
            Conditions.add([CCountSource, CComparison, CValue, C_CondGateChain_AND]);
        }
        if(Conditions.count > 0) {
            Conditions[Conditions.count - 1][C_CondGateChain] = C_CondGateChain_OR;
        }
    }

    return Conditions.count > 0;
}

Integer GetConditionalCount(Integer _Source) {
    switch(_Source) {
        case C_CondGateCountSource_Players   : return Players.count;
        case C_CondGateCountSource_Survivors : return Players.count - G_InfectedPlayerCount;
        case C_CondGateCountSource_Infected  : return G_InfectedPlayerCount;
    }
    return 0;
}

Boolean Compare(Integer _Count, Integer _Comparison, Integer _Value) {
    switch(_Comparison) {
        case C_CondGateComparison_LT : return _Count < _Value;
        case C_CondGateComparison_EQ : return _Count == _Value;
        case C_CondGateComparison_GT : return _Count > _Value;
    }
    return False;
}

Void SetupConditionalGate(CSmMapLandmark _Gate) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    Gate.Automatic = False;
    Gate.Clan      = C_InfectedClanNum;
    Gauge.Clan     = C_InfectedClanNum;
    Gauge.Speed    = 0;
}

Void UpdateGateStatus(CSmMapLandmark _Gate) {
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;
    declare Boolean UpdateAlways   for _Gate = False;

    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    declare Boolean Result = False;
    declare Integer PrevChain = -1;
    foreach(Condition in Conditions) {
        declare CurrentResult = Compare(
            GetConditionalCount(Condition[C_CondGateCountSource]),
            Condition[C_CondGateComparison],
            Condition[C_CondGateValue]
        );
        if(PrevChain == -1) {
            // Initialize result
            Result = CurrentResult;
        } else {
            // Chain the result
            switch(Condition[C_CondGateChain]) {
                case C_CondGateChain_AND : Result = Result && CurrentResult;
                case C_CondGateChain_OR  : Result = Result || CurrentResult;
                default: Result = False;
            }
        }
    }

    declare Open = DefaultOpened;
    if(Result) {
        // Toggle `Open` status if the conditiona result is True
        Open = !Open;
    }

    if(Open) {
        Gauge.ValueReal = 0.0;
    } else {
        Gauge.ValueReal = 1.0;
    }
    Gauge.Captured = !Open;
    Gate.ManualClosed = !Open;
}

Text GenerateManialink() {
    return """
        <label style="TextRaceChrono" posn="120 -69" valign="center" halign="right" textcolor="{{{TL::ColorToText(C_InfectedColor)}}}" text="{{{G_InfectedPlayerCount}}}" id="Infected"/>
        <label style="TextRaceChrono" posn="121 -72" valign="center" halign="center" textcolor="fff" text="/" />
        <label style="TextRaceChrono" posn="122 -75" valign="center" halign="left" textcolor="fff" text="{{{Players.count}}}" id="Players"/>
        <label posn="128 -76" valign="center" halign="left" textcolor="fff" text="infected" />

        <label style="TextTitle1" posn="0 20" halign="center" visible="false" textcolor="f00" id="Idle_Text">{{{C_IdlePlayerWarning}}}</label>
        <label style="TextRaceChrono" posn="0 15" halign="center" visible="false" id="Idle_Time" />

        <frame id="NearestSurvivorFrame">
            <frame>
                <gauge posn="-21 -87" ratio="0.5" clan="{{{C_InfectedClanNum}}}" sizen="53 8" rot="180" id="NearestSurvivor" />
                <quad posn="-27 -76 10" sizen="14 14" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" />
                <quad posn="-26 -77 11" sizen="12 12" image="file:///Media/Manialinks/ShootMania/Common/MainPlayer.dds" id="SurvivorImage" />
            </frame>
            <quad posn="-0.3 0.3 0" sizen="0.6 0.6" bgcolor="fff" />
        </frame>
        <script>
        <!--
        {{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
        {{{Manialink::Animations(["EaseInOutQuad"])}}}
        main() {
            declare netread Net_InfectedCount   for Teams[0] = 0;
            declare netread Net_PlayerCount     for Teams[0] = 0;
            declare netread Net_Infected        for InputPlayer = False;
            declare netread Net_NearestSurvivor for InputPlayer = 0.0;

            declare Real NearestSurvivor = 0.0;
            declare Boolean IsSpawned = False;

            declare Label_Infected        = (Page.GetFirstChild("Infected")             as CMlLabel);
            declare Label_Players         = (Page.GetFirstChild("Players")              as CMlLabel);
            declare Label_Idle_Text       = (Page.GetFirstChild("Idle_Text")            as CMlLabel);
            declare Label_Idle_Time       = (Page.GetFirstChild("Idle_Time")            as CMlLabel);
            declare Frame_NearestSurvivor = (Page.GetFirstChild("NearestSurvivorFrame") as CMlFrame);

            while(True) {
                yield;

                IsSpawned = InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned;

                Label_Infected.Value = TL::ToText(Net_InfectedCount);
                Label_Players.Value  = TL::ToText(Net_PlayerCount);

                Frame_NearestSurvivor.Visible = Net_Infected && IsSpawned;
                if(Frame_NearestSurvivor.Visible) {
                    LibManialink_AnimLoop();
                    if(Net_NearestSurvivor != NearestSurvivor) {
                        NearestSurvivor = Net_NearestSurvivor;

                        if(NearestSurvivor < 0.0)
                            NearestSurvivor = 0.0;
                        if(NearestSurvivor > 1.0)
                            NearestSurvivor = 1.0;

                        declare Intensity = 0.5 + NearestSurvivor / 2.0;
                        LibManialink_Anim("<gauge id=\"NearestSurvivor\" ratio=\"" ^ Net_NearestSurvivor ^ "\" />", 200, "EaseInOutQuad");
                        LibManialink_Anim("<quad id=\"SurvivorImage\" colorize=\"" ^ TL::ColorToText(<0.0, Intensity, 0.0>) ^ "\" />", 200, "EaseInOutQuad");
                    }
                }

                if({{{S_ForceSpecAfter > 0}}}) {
                    if(IsSpawned && InputPlayer.IdleDuration >= {{{S_ForceSpecAfter * 0.8}}}) {
                        declare Integer TimeLeft = {{{S_ForceSpecAfter}}} - InputPlayer.IdleDuration;
                        Label_Idle_Text.Opacity  = 0.5 + 0.5 * ML::Sin(Now / (50.0 * ML::PI()));
                        Label_Idle_Text.Visible  = True;
                        if(TimeLeft >= 0) {
                            Label_Idle_Time.Value = TL::TimeToText(TimeLeft);
                        }
                        Label_Idle_Time.Visible = TimeLeft >= 0;
                    } else {
                        Label_Idle_Text.Visible = False;
                        Label_Idle_Time.Visible = False;
                    }
                }
            }
        }
        -->
        </script>""";
}

