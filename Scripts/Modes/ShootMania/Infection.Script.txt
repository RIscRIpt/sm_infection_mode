#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const Version    "2017-02-22"
#Const ScriptName "Infection.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Color.Script.txt" as Color
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Scores
#Include "Libs/Nadeo/ShootMania/ScoresTable_Edit.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink

#Setting S_HorizontalInfectionDistance      0.61        as "horizontal infection distance"
#Setting S_VerticalInfectionDistance        2.16        as "vertical infection distance"
#Setting S_InfectionScore                   4           as "infection score"
#Setting S_InfectionArmorBonus              100         as "armor bonus for infection"
#Setting S_PVP                              False       as "enable PvP for survivors"
#Setting S_PursuitMode                      0           as "pursuit mode (0=off, 1=normal ammo, 2=inf ammo)"
#Setting S_UsePVPCollisions                 False       as "use PvP collisions (need round restart)"
#Setting S_UseClans                         True        as "use teams (need map restart)"
#Setting S_UseSameWallJump                  False       as "allow escalator jump (need round restart)"
#Setting S_HitSurvivorScore                 0           as "hit survivor score (for PvP mode)"
#Setting S_HitInfectedScore                 1           as "hit infected score"
#Setting S_ScoreForSurv1Inf                 1           as "score for surviving single infection"
#Setting S_TimeLimit                        300000      as "time limit for a round"
#Setting S_ScoreLimit                       100         as "score limit for a match"
#Setting S_RoundLimit                       0           as "round limit for a match"
#Setting S_RespawnOnInfection               True        as "respawn on infection"
#Setting S_InfectedShoot                    1           as "allow first N infected to shoot"
#Setting S_InfectedWAmmoGain                1.0         as "<hidden>"
#Setting S_InfectedWLaserMax                0           as "<hidden>"
#Setting S_InfectedWRocketMax               1           as "<hidden>"
#Setting S_InfectedWNucleusMax              0           as "<hidden>"
#Setting S_InfectedWArrowMax                0           as "<hidden>"
#Setting S_PreparationTime                  10000       as "time till first infection"
#Setting S_InfectNewPlayers                 True        as "infect new players"
#Setting S_RewardInfectors                  0.5         as "rewarding infected `parent` cooef."
#Setting S_SurvivorStamina                  1.0         as "survivor stamina (0.1-3.0)"
#Setting S_SurvivorStaminaGain              0.7         as "survivor stamina gain (0.0-1.0,10)"
#Setting S_InfectedStamina                  2.0         as "infected stamina (0.1-3.0)"
#Setting S_InfectedStaminaGain              1.0         as "infected stamina gain (0.0-1.0,10)"
#Setting S_SurvivorRespawnArmor             1           as "survivor respawn armor"
#Setting S_SurvivorMaxArmor                 1           as "survivor maximum armor"
#Setting S_InfectedRespawnArmor             2           as "infected respawn armor"
#Setting S_InfectedMaxArmor                 2           as "infected maximum armor"
#Setting S_RewardFirstInfected              0.5         as "<hidden>"
#Setting S_SurvivorDetectorMaxDist          20.0        as "survivor detector max distance"
#Setting S_RespawnDelay                     1000        as "respawn delay"
#Setting S_CanLeaveMapFor                   3000        as "can leave map for (ms)"
#Setting S_ForceSpecAfter                   60000       as "force inactive players to spectators after (ms)"
#Setting S_CanIdleAfterSpawn                10000       as "player can be idle after spawning for (ms)"
#Setting S_InfectOnPreparationRespawn       False       as "infect on respawn during preparation"

#Const   C_MinimalPlayerCount               2
#Const   C_InfectOnRespawn                  True        //as "infect on respawn"
#Const   C_InfectionTick                    30
#Const   C_SurvivorColor                    <1.0, 0.0, 0.0>
#Const   C_SurvivorHasShield                True
#Const   C_SurvivorIsHighlighted            True
#Const   C_SurvivorEnergyLevel              1.0
#Const   C_InfectedColor                    <0.0, 0.5, 0.0>
#Const   C_InfectedHasShield                True
#Const   C_InfectedIsHighlighted            False
#Const   C_InfectedEnergyLevel              1.0
#Const   C_RoundPauseTime                   4000
#Const   C_MatchPauseTime                   6000

#Const   C_MainManialinkLayer               "Infection_MainManialinkLayer"

#Const   C_SurvivorTeamId                   0
#Const   C_InfectedTeamId                   1
#Const   C_SurvivorClanNum                  1
#Const   C_InfectedClanNum                  2

#Const   C_TxtUnkTime                       "--:--.--"
#Const   C_TxtSurvivor                      "$f00Survivor"
#Const   C_TxtInfected                      "$080Infected"
#Const   C_TxtSpectator                     "$aaaSpectator"

#Const   C_TxtInfectedBy                    "Infected by: "
#Const   C_TxtInfectedFooter                "Infect $f00survivors$z!"
#Const   C_TxtSurvivorFooter                "Avoid $080infected $zplayers!"
#Const   C_TxtSpectatorFooter               ""

#Const   C_TopHits                          "Hits"
#Const   C_TitleTopHits                     "Top Hits"
#Const   C_TopInfections                    "Infs"
#Const   C_TitleTopInfections               "Top Infections"
#Const   C_TopSurivals                      "Srvs"
#Const   C_TitleTopSurvivals                "Top Survivals"

#Const   C_TxtRules                         "Free for all. You spawn as a survivor, if you die you respawn infected. Infected players can't shoot, but can infect other players by touching them. The match ends when a player reaches the score limit or the round limit is reached."
#Const   C_TxtRoundEnd                      "A round ends either if no survivors are left or if the time limit is reached."
#Const   Description                        "TYPE: Free For All\nOBJECTIVE:\nSurvive as long as possible and then infect other people."

#Const   C_PlayerIsIdle                     "$z$s is idle."
#Const   C_WasIdleTooLongMovingToSpec       "$z$s was idle for too long. Moving to spectators."
#Const   C_IdlePlayerWarning                "$sYou are considered inactive!"

#Const   C_TxtYouInfectedA                  "$0f0You infected $fff%1"
#Const   C_TxtAInfectedYou                  "%1 $z$s$0f0infected you"
#Const   C_TxtAInfectedB                    "%1 $z$sinfected %2"

#Const   C_TxtPlayerDrowned                 "$z$s drowned in water!"
#Const   C_TxtPlayerInfectedByWater         "%1 $z$swas infected by water!"
#Const   C_TxtPlayerWasEliminated           "%1 $z$swas very curious and got aids!"

#Const   C_TxtAllPlayersInfected            "All players are infected!"
#Const   C_TxtTimeLimitReached              "Time limit reached!"
#Const   C_TxtNPlayersSurvivied             "$f00%1 $fffplayer(s) survived!"
#Const   C_TxtNoMoreInfected                "No more infected players!"

#Const   C_TxtGetBackToBattleField          "Get back to the battlefield!"
#Const   C_TxtYouWillBeInfectedInX          "You will be infected in $080%1"

#Const   C_LastSurvivorMsgDuration          6000
#Const   C_LastSurvivorMsgPriority          2

#Const   C_ArmorUnit                        100
#Const   C_ArmorReplenishGain               300

#Const   C_StaminaRealUnit                  1.0
#Const   C_StaminaIntUnit                   3600
#Const   C_StaminaMinGain                   0.0
#Const   C_StaminaMaxGain                   1.0

#Const   C_Cond_TxtPrefix                   "$f00[CondLandmark] $z$s"

#Const   C_Cond_CountSource                 0
#Const   C_Cond_Comparison                  1
#Const   C_Cond_Value                       2
#Const   C_Cond_Chain                       3

#Const   C_Cond_TxtPlayers                  "P"
#Const   C_Cond_TxtSurvivors                "S"
#Const   C_Cond_TxtInfected                 "I"

#Const   C_Cond_Players                     0
#Const   C_Cond_Survivors                   1
#Const   C_Cond_Infected                    2

#Const   C_Cond_Comparison_LT               0
#Const   C_Cond_Comparison_EQ               1
#Const   C_Cond_Comparison_GT               2

#Const   C_Cond_Chain_None                  -1
#Const   C_Cond_Chain_AND                   0
#Const   C_Cond_Chain_OR                    1

#Const   C_MapSetting_Water                         "W"
#Const   C_MapSetting_WaterProperty_TxtEliminates   "E"
#Const   C_MapSetting_WaterProperty_TxtProtects     "P"
#Const   C_MapSetting_WaterProperty_TxtInfects      "I"
#Const   C_MapSetting_WaterProperty_TxtHeals        "H"

#Const   C_UnexpectedBehaviour "Unexpected behaviour!\nThis must not happen!\nWhere: %1\nData: %2"

/* -------------------------------------- */
// Globals
/* -------------------------------------- */

declare Ident   G_RoundInfoLayerId;
declare Integer G_InfectedPlayerCount;
declare Ident   G_FirstInfectedId;

declare CSmMapLandmark[] G_CondGates_Up_Always;
declare CSmMapLandmark[] G_CondGates_Up_EachRound;

declare CSmMapLandmark[] G_SurvivorSpawns;
declare CSmMapLandmark[] G_InfectedSpawns;

// No bitfield operations, so declaring bunch of booleans
declare Boolean G_MapSetting_WaterHasEffects;

declare Boolean G_MapSetting_WaterForSurvivors_Eliminates;
declare Boolean G_MapSetting_WaterForSurvivors_Protects;
declare Boolean G_MapSetting_WaterForSurvivors_Infects;
declare Boolean G_MapSetting_WaterForSurvivors_Heals;

declare Boolean G_MapSetting_WaterForInfected_Eliminates;
declare Boolean G_MapSetting_WaterForInfected_Protects;
declare Boolean G_MapSetting_WaterForInfected_Heals;

***InitServer***
***
UIManager.UILayerDestroyAll();
UIManager.UIAll.AltMenuNoCustomScores = True;
UIManager.UIAll.AltMenuNoDefaultScores = True;
G_RoundInfoLayerId = UIManager.UILayerCreate().Id;
***

***StartServer***
***
SM::SetupDefaultVisibility();
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;

Color::Load(); //?

/* -------------------------------------- */
// Create the rules
declare ModeName = "Infection";
SpawnScreen::SetModeName(ModeName);
SpawnScreen::AddSubsection("Rules", C_TxtRules, 0.);
SpawnScreen::AddSubsection("Round end", C_TxtRoundEnd, 35.);
SpawnScreen::AddSubsection("Description", """- Survivors are $f00red$g, Infecteds are $360green$g.
- the first infected gets some points if all players are infected
- the first infected can shoot until there is a second infected
- when an infected player infects another player he regenerates one armor""", 60.);
SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores();
SpawnScreen::CreatePrettyRules(ModeName);

/* -------------------------------------- */
// Iniz tops
Top::Load();
Top::SetTopWidth(65.);
declare Real TopXPosition = -62.5;
declare Real TopYPosition = 42.;
declare Real TopXOffset = 65.;
declare Integer PlayersNbPerTop = 14;
declare Text TopBGImg = "file://Media/Manialinks/Shootmania/Common/topsBg.dds";
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
Top::Create(C_TopHits, C_TitleTopHits, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopInfections, C_TitleTopInfections, PlayersNbPerTop, <TopXPosition, TopYPosition>);
TopXPosition += TopXOffset;
Top::Create(C_TopSurivals, C_TitleTopSurvivals, PlayersNbPerTop, <TopXPosition, TopYPosition>);
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
// Init scores table
ScoresTable::Load();
ScoresTable::SetTableWidth(190.);
ScoresTable::SetColumnWidth("Custom1", 10.);
ScoresTable::SetDefaultCustom1(C_TxtSurvivor);
ScoresTable::SetColumnWidth("Custom2", 7.);
ScoresTable::SetDefaultCustom2(C_TxtUnkTime);
ScoresTable::SetColumnName("Custom2", "Survival Time");
ScoresTable::SetColumnWidth("Custom3", 8.);
ScoresTable::SetDefaultCustom3("$3600$fff/$f000$fff/$ff00");
ScoresTable::SetColumnName("Custom3", "$360Inf$fff/$f00Hit$fff/$ff0Surv");
ScoresTable::SetColumnWidth("RoundPoints", 5.);
ScoresTable::SetColumnWidth("Points", 5.);
ScoresTable::SetTableFormat(2, 7);
ScoresTable::SetDefaultFooterStats("Version: " ^ Version);
ScoresTable::Build(True, False);
//Init Tabs
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer(
[
    "TopTab"    => "Buddies",
    "ScoresTab" => "Rankings"

], 30, -5, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);
ScoresTable::GetLayerScoresTable().Type = CUILayer::EUILayerType::Normal;

Layers::Create(C_MainManialinkLayer, GenerateManialink());
***

***StartMap***
***
UseClans       = S_UseClans;
UseForcedClans = S_UseClans;

// Required for manialink clan colors
Teams[C_SurvivorTeamId].ColorPrimary = C_SurvivorColor;
Teams[C_InfectedTeamId].ColorPrimary = C_InfectedColor;

UIManager.UIAll.MarkersXML = "";

G_InfectedPlayerCount = 0;
G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();

G_MapSetting_WaterHasEffects              = False;

G_MapSetting_WaterForSurvivors_Eliminates = False;
G_MapSetting_WaterForSurvivors_Protects   = False;
G_MapSetting_WaterForSurvivors_Infects    = False;
G_MapSetting_WaterForSurvivors_Heals      = False;

G_MapSetting_WaterForInfected_Eliminates  = False;
G_MapSetting_WaterForInfected_Protects    = False;
G_MapSetting_WaterForInfected_Heals       = False;

foreach(Landmark in MapLandmarks) {
    declare Tags = TL::Split("_", Landmark.Tag);
    switch(Tags[0]) {
        case "Spawn":
        {
            SetupCustomSpawn(Landmark);
        }
        case "Tornado":
        {
            if(Tags.count == 2) {
                OffZoneCenterLandmarkId = Landmark.Id;
                OffZoneRadius = TL::ToReal(Tags[1]);
            }
        }
        case "Gate":
        {
            if(SetupGateConditions(Landmark)) {
                declare Boolean UpdateAlways for Landmark = False;
                if(UpdateAlways)
                    G_CondGates_Up_Always.add(Landmark);
                else
                    G_CondGates_Up_EachRound.add(Landmark);
                SetupConditionalGate(Landmark);
            }
        }
        case "Settings":
        {
            if(Tags.count > 1) {
                SetupMapSettings(Tags[1]);
            }
        }
    }
}

ScoresTable::StartMatch();
Scores::MatchBegin();

Top::ResetAll();

foreach(Player in Players) {
    declare Integer Match_Infections for Player;
    declare Integer Match_Hits       for Player;
    declare Integer Match_Survivals  for Player;

    Match_Infections = 0;
    Match_Hits       = 0;
    Match_Survivals  = 0;
}
***

***InitRound***
***
declare Integer PrevInfectionTickTime;
declare Boolean InfectionStarted;

PrevInfectionTickTime = -1;
InfectionStarted      = False;

UseSameWallJump  = S_UseSameWallJump;
UsePvPWeapons    = (S_PursuitMode == 0);
UsePvPCollisions = S_UsePVPCollisions;

MB_UseSectionRound = True;
***


***StartRound***
***
Scores::RoundBegin();

UIManager.UIAll.UISequence      = CUIConfig::EUISequence::Playing;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Default;

G_FirstInfectedId     = NullId;
G_InfectedPlayerCount = 0;

foreach(Player in AllPlayers) {
    declare netwrite Boolean Net_Infected     for Player;
    declare netwrite Real Net_NearestSurvivor for Player;

    declare Ident InfectorId      for Player;
    declare Boolean Infected      for Player;
    declare Integer SpawnTime     for Player;
    declare Integer InfectionTime for Player;

    declare Integer Round_Infections for Player;
    declare Integer Round_Hits       for Player;
    declare Integer Round_Survivals  for Player;

    Net_Infected        = False;
    Net_NearestSurvivor = 0.0;

    InfectorId          = NullId;
    Infected            = False;
    SpawnTime           = -1;
    InfectionTime       = -1;

    Round_Infections = 0;
    Round_Hits       = 0;
    Round_Survivals  = 0;
}

UpdateModeStatusMessage();

StartTime = Now + 1000;
if(Players.count >= C_MinimalPlayerCount) {
    EndTime = Now + 1000 + S_PreparationTime;
} else {
    // Not enough players
    EndTime = -1;
    UIManager.UIAll.BigMessage    = "$f92Waiting for Players";
    UIManager.UIAll.StatusMessage = TL::Compose("At least $f00%1 $fffplayers are needed!", TL::ToText(C_MinimalPlayerCount));
}

UIManager.UIAll.UILayers.add(UIManager.UILayers[G_RoundInfoLayerId]);

// Update conditional gates
foreach(Gate in G_CondGates_Up_EachRound) {
    UpdateGateStatus(Gate, True);
}
foreach(Gate in G_CondGates_Up_Always) {
    UpdateGateStatus(Gate, True);
}
***


***InitTurn***
***
MB_UseSectionTurn = False;
***

***OnNewPlayer***
***
declare netwrite Boolean Net_Infected     for Player;
declare netwrite Real Net_NearestSurvivor for Player;

declare Ident InfectorId      for Player = NullId;
declare Boolean Infected      for Player;
declare Integer SpawnTime     for Player = -1;
declare Integer InfectionTime for Player = -1;

Infected            = InfectionStarted && S_InfectNewPlayers;
Net_Infected        = Infected;
Net_NearestSurvivor = 0.0;

UpdateTable(Player);

ScoresTable::RestoreCustomScores(Player);
declare UI <=> UIManager.GetUI(Player);
Tabs::UseTabs(UI, "ScoresTab");
Tabs::AlwaysShowScore(UI, True);

if(Layers::IsMissing(C_MainManialinkLayer, Player.Id)) {
    Layers::Attach(C_MainManialinkLayer, Player.Id);
}
***

***OnNewSpectator***
***
UpdateTable(Spectator);

ScoresTable::RestoreCustomScores(Spectator);

declare UI <=> UIManager.GetUI(Spectator);
Tabs::UseTabs(UI, "ScoresTab");
Tabs::AlwaysShowScore(UI, True);

if(UI != Null) {
    UI.SpectatorForcedClan      = 0;
    UI.SpectatorForceCameraType = 15;
}

if(Layers::IsMissing(C_MainManialinkLayer, Spectator.Id)) {
    Layers::Attach(C_MainManialinkLayer, Spectator.Id);
}
***

***PlayLoop***
***
if(PrevInfectionTickTime + C_InfectionTick < Now) {
    PrevInfectionTickTime = Now;

    declare CSmPlayer[] UnspawnedPlayers;

    foreach(Player in Players) {
        if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
            UnspawnedPlayers.add(Player);
            continue;
        }
        if(Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
            continue;
        }

        if(IsInfected(Player)) {
            // Infected

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForInfected(Player);
            }

            // Provide infinite stamina for infected
            if(S_InfectedStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check for infection and nearest survivor
            ManageInfectedPlayer(Player);
        } else {
            // Survivor

            if(G_MapSetting_WaterHasEffects) {
                ManageMapWaterEffectsForSurvivor(Player);
            }

            // Provide infinite stamina for survivor
            if(S_SurvivorStaminaGain > C_StaminaMaxGain) {
                Player.Stamina = C_StaminaIntUnit;
            }

            // Check if leaving the map, and take some actions
            ManageMapLeaver(Player);
        }
        ManageIdlePlayer(Player);
    }

    if(UnspawnedPlayers.count > 0)
        SpawnAndInitPlayers(UnspawnedPlayers, InfectionStarted || S_InfectOnPreparationRespawn);

    Message::Loop();
    Top::Loop();
}

if(EndTime > -1 && EndTime <= Now) {
    if(!InfectionStarted && Players.count >= C_MinimalPlayerCount) {
        // Begin infection round
        InfectionStarted = True;

        if(S_TimeLimit > 0) {
            EndTime = Now + S_TimeLimit;
        } else {
            EndTime = -1;
        }

        declare FirstInfected = GetFirstInfected();
        if(FirstInfected != Null) {
            Infect(FirstInfected);

            Message::SendStatusMessage("$iLet the infection begin...", 4000, 1);
            Message::SendBigMessage(FirstInfected, "$360First Infected!", 4000, 1);
            foreach(Survivor in AllPlayers) {
                if(IsInfected(Survivor))
                    continue;

                Message::SendBigMessage(Survivor, FirstInfected.Name ^ "$z$s$360 is the first infected!", 4000, 1);
            }
        } else {
            // This must not happen
            log(TL::Compose(C_UnexpectedBehaviour, "Choosing first infected", "Null"));
            MB_StopRound();
        }
    } else {
        // End infection round
        MB_StopRound();
    }
}

foreach(Event in PendingEvents) {
    switch(Event.Type) {
        case CSmModeEvent::EType::OnHit:
        {
            if(Event.Shooter == Event.Victim
            || IsProtectedByMap(Event.Victim))
            {
                Discard(Event);
                continue;
            }
            declare ShooterInfected = IsInfected(Event.Shooter);
            declare VictimInfected  = IsInfected(Event.Victim);
            if(VictimInfected && !ShooterInfected) {
                // OnSurvivorHitInfected
                if(S_HitInfectedScore != 0) {
                    OnHit(Event, S_HitInfectedScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && !ShooterInfected) {
                // OnSurvivorHitSurvivor
                if(S_PVP && S_HitSurvivorScore != 0) {
                    OnHit(Event, S_HitSurvivorScore);
                    PassOn(Event);
                } else {
                    Discard(Event);
                }
            } else if(!VictimInfected && ShooterInfected) {
                // OnInfectedHitSurvivor
                Infect(Event.Victim, Event.Shooter);
                Discard(Event);
            } else {
                // OnInfectedHitInfected
                Discard(Event);
            }
        }
        default:
            PassOn(Event);
    }
}

declare netwrite Integer Net_PlayerCount   for Teams[0];
declare netwrite Integer Net_InfectedCount for Teams[0];

declare Integer Prev_PlayerCount         for This = -1;
declare Integer Prev_InfectedPlayerCount for This = -1;

declare Boolean PlayerCountChanged = False;

// The most reliable way of checking of player count changes.
// It's done in one place, so updated only once per playloop iteration.
if(Prev_PlayerCount != Players.count) {
    PlayerCountChanged = True;

    if(Prev_PlayerCount < C_MinimalPlayerCount && Players.count >= C_MinimalPlayerCount) {
        // If it's enough players now, restart round!
        MB_StopRound();
    } else if(Prev_PlayerCount >= C_MinimalPlayerCount && Players.count < C_MinimalPlayerCount) {
        // If it's not enough players now, restart round and display message!
        MB_StopRound();
    }

    Prev_PlayerCount = Players.count;
    Net_PlayerCount  = Prev_PlayerCount;

    // Infected player count might be changed too
    G_InfectedPlayerCount = CountInfected();
}
if(Prev_InfectedPlayerCount != G_InfectedPlayerCount) {
    PlayerCountChanged = True;

    // If previously infected could shoot and now they cannot shoot, or
    // infected couldn't shoot previously and now they can shoot
    if((Prev_InfectedPlayerCount <= S_InfectedShoot && G_InfectedPlayerCount >  S_InfectedShoot) ||
        Prev_InfectedPlayerCount >  S_InfectedShoot && G_InfectedPlayerCount <= S_InfectedShoot)
    {
        // Re-setup infector weapons
        foreach(Infected in Players) {
            if(!IsInfected(Infected)) {
                continue;
            }
            SetupInfectedWeapons(Infected);
        }
    }

    Prev_InfectedPlayerCount = G_InfectedPlayerCount;
    Net_InfectedCount        = G_InfectedPlayerCount;
}
if(PlayerCountChanged) {
    // If player count (survivor or infected) changed, update conditional gates
    PlayerCountChanged = False;
    foreach(Gate in G_CondGates_Up_Always) {
        UpdateGateStatus(Gate, False);
    }
    UpdateModeStatusMessage();
}

if((InfectionStarted && G_InfectedPlayerCount == 0) || (G_InfectedPlayerCount >= Players.count)) {
    // Don't end the round if not enough players
    if(Players.count >= C_MinimalPlayerCount) {
        MB_StopRound();
    }
}

***

***EndRound***
***
StartTime = -1;
EndTime   = -1;

if(S_RewardFirstInfected > 0.0 && Players.existskey(G_FirstInfectedId)) {
    declare FirstInfected <=> Players[G_FirstInfectedId];
    Scores::AddPoints(FirstInfected, ML::NearestInteger(G_InfectedPlayerCount * S_RewardFirstInfected));
}

// Clean UI
Message::CleanAllMessages();

// Display result
UIManager.UIAll.UILayers.removekey(G_RoundInfoLayerId);
UIManager.UIAll.UISequence           = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound      = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.StatusMessage        = "";

if(G_InfectedPlayerCount >= Players.count) {
    UIManager.UIAll.BigMessage = C_TxtAllPlayersInfected;
} else if(G_InfectedPlayerCount == 0) {
    UIManager.UIAll.BigMessage = C_TxtNoMoreInfected;
    MB_SectionRoundNb -= 1;
} else {
    UIManager.UIAll.BigMessage    = C_TxtTimeLimitReached;
    UIManager.UIAll.StatusMessage = TL::Compose(C_TxtNPlayersSurvivied, TL::ToText(Players.count - G_InfectedPlayerCount));
}

// Check for limits
if(S_ScoreLimit > 0) {
    foreach(Player in Players) {
        if(Player.Score != Null && Player.Score.Points >= S_ScoreLimit) {
            MB_StopMap();
            break;
        }
    }
}

if(S_RoundLimit > 0 && MB_SectionRoundNb >= S_RoundLimit) {
    MB_StopMap();
}

Top::Loop();
Scores::RoundEnd();

sleep(C_RoundPauseTime);

UIManager.UIAll.StatusMessage        = "";
UIManager.UIAll.BigMessage           = "";
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

SM::UnspawnAllPlayers();
DestroyAllBotPlayers();
***

***EndMap***
***
Scores::MatchEnd();
ScoresTable::EndMatch();

UIManager.UIAll.BigMessage    = "";
UIManager.UIAll.StatusMessage = "";

declare CSmPlayer[] MaxScores;
declare Integer MaxScore = 0;
foreach(Player in Players) {
    if(Player.Score != Null) {
        if(MaxScore < Player.Score.Points) {
            MaxScores.clear();
            MaxScores.add(Player);
            MaxScore = Player.Score.Points;
        } else if (MaxScore == Player.Score.Points) {
            MaxScores.add(Player);
        }
    }
}

foreach(Player in AllPlayers) {
    Layers::Detach(C_MainManialinkLayer, Player.Id);
}

if(MaxScore == 0) {
    UIManager.UIAll.BigMessage = _("|Match|Draw");
} else if(MaxScores.count > 0) {
    declare Text PlayerNames = MaxScores[0].Name;
    for(I, 1, MaxScores.count - 1) {
        if(I < MaxScores.count - 1) {
            PlayerNames ^= ", " ^ MaxScores[I].Name;
        } else {
            if(MaxScores.count > 2)
                PlayerNames ^= ",";
            PlayerNames ^= " and " ^ MaxScores[I].Name;
        }
    }

    if(MaxScores.count > 1) {
        UIManager.UIAll.BigMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    } else {
        UIManager.UIAll.StatusMessage = TL::Compose("%1 $z$swon the match.", PlayerNames);
    }
}

UIManager.UIAll.UISequence              = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.BigMessageSound         = CUIConfig::EUISound::EndRound;
UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence              = CUIConfig::EUISequence::Podium;

sleep(C_MatchPauseTime);

UIManager.UIAll.ScoreTableVisibility    = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage              = "";
UIManager.UIAll.StatusMessage           = "";

G_InfectedSpawns.clear();
G_SurvivorSpawns.clear();
OffZoneRadius = -1.0;
G_CondGates_Up_Always.clear();
G_CondGates_Up_EachRound.clear();
***

***EndServer***
***
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
UIManager.ResetAll();
UIManager.UILayerDestroyAll();

Color::Unload();
ScoresTable::Unload();
***

Boolean IsInfected(CSmPlayer _Player) {
    if(_Player != Null) {
        declare Infected for _Player = S_InfectNewPlayers;
        return Infected;
    }
    return False;
}

Integer CountInfected() {
    declare Integer Count = 0;
    foreach(Player in Players) {
        if(IsInfected(Player))
            Count += 1;
    }
    return Count;
}

Void OnPlayerCountChanged() {

}

Real ML__FMod(Real _Value, Real _Mod) {
    return _Value - ML::ToReal(ML::FloorInteger(_Value / _Mod)) * _Mod;
}

Real RealRandom(Real _Max) {
    declare Real Rand = ML::Rand(0.0, _Max);
    foreach(Player in Players) {
        Rand = ML__FMod(Rand + Player.Position.X +
                               Player.Position.Y +
                               Player.Position.Z, _Max);
    }
    return Rand;
}

Real SigmoidProbability(Real _X, Real _Max) {
    //https://www.wolframalpha.com/input/?i=plot+y+%3D+(100+-+100%2F(1+%2B+(x%2F(100*2%2F3))%5E6)%5E2)%2F100,+x%3D0..100
    if(_Max <= 0.000001) {
        return 1.0;
    }
    return 1 - 1 / (
                    ML::Pow(1 + ML::Pow(_X / (_Max * 2 / 3), 6.0), 2.0)
                   );
}

CSmPlayer GetFirstInfected() {
    if(G_FirstInfectedId != NullId) {
        if(Players.existskey(G_FirstInfectedId)) {
            return Players[G_FirstInfectedId];
        }
        G_FirstInfectedId = NullId;
    }

    declare Integer IMaxPoints = -1;
    declare Real    RMaxPoints = -1.0;
    declare Real    SumProb    = 0.0;
    declare Real    RandomNum;

    // Find Max Score
    foreach(Player in Players) {
        if(Player.Score != Null) {
            if(IMaxPoints < Player.Score.Points)
                IMaxPoints = Player.Score.Points;
        }
    }
    RMaxPoints = ML::ToReal(IMaxPoints);

    // Calculate probabilities of being chosen
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player;
        declare Real Points = 0.0;
        if(Player.Score != Null)
            Points = ML::ToReal(Player.Score.Points);
        ProbFirstInf = SigmoidProbability(Points, RMaxPoints);
        SumProb += ProbFirstInf;
    }

    RandomNum = RealRandom(SumProb);
    foreach(Player in Players) {
        declare Real ProbFirstInf for Player = 0.0;
        RandomNum -= ProbFirstInf;
        if(RandomNum <= 0.0) {
            G_FirstInfectedId = Player.Id;
            return Player;
        }
    }

    // This must not happen
    log(TL::Compose(C_UnexpectedBehaviour, "GetFirstInfected", "" ^ RandomNum));
    if(Players.count > 0) {
        G_FirstInfectedId = Players[0].Id;
        return Players[0];
    }

    G_FirstInfectedId = NullId;
    return Null;
}

Void SetupArmor(CSmPlayer _Player, Integer _Max, Integer _Current) {
    if(_Max > 0) {
        _Player.ArmorMax = _Max * C_ArmorUnit;
    }
    if(_Current > 0) {
        _Player.Armor = _Current * C_ArmorUnit;
    }
    if(_Player.Armor > _Player.ArmorMax) {
        _Player.Armor = _Player.ArmorMax;
    }
}

Void SetupStamina(CSmPlayer _Player, Real _Gain, Real _Max) {
    if(_Gain > C_StaminaMaxGain) {
        _Player.StaminaMax = C_StaminaRealUnit;
    } else {
        _Player.StaminaMax = ML::Clamp(_Max, 0.1, 3.0);
    }
    _Player.StaminaGain = ML::Clamp(_Gain, C_StaminaMinGain, C_StaminaMaxGain);

}

Void InitSurvivor(CSmPlayer _Player) {
    _Player.ForceColor    = C_SurvivorColor;
    _Player.HasShield     = C_SurvivorHasShield;
    _Player.IsHighlighted = C_SurvivorIsHighlighted;
    _Player.EnergyLevel   = C_SurvivorEnergyLevel;

    SetupArmor(_Player, S_SurvivorMaxArmor, S_SurvivorRespawnArmor);
    SetupStamina(_Player, S_SurvivorStaminaGain, S_SurvivorStamina);
}

Void InitInfected(CSmPlayer _Player) {
    _Player.ForceColor    = C_InfectedColor;
    _Player.HasShield     = C_InfectedHasShield;
    _Player.IsHighlighted = C_InfectedIsHighlighted;
    _Player.EnergyLevel   = C_InfectedEnergyLevel;

    SetupArmor(_Player, S_InfectedMaxArmor, S_InfectedRespawnArmor);
    SetupStamina(_Player, S_InfectedStaminaGain, S_InfectedStamina);
}

Void SetupSurvivorWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    switch(S_PursuitMode) {
        case 0:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   2);
        }
        case 1:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   3);
        }
        case 2:
        {
            _Player.AmmoGain = 10.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   10);
        }
    }

    //SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket));
    //if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
    //    SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
    //}
}

Void SetupInfectedWeapons(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    switch(S_PursuitMode) {
        case 0:
        {
            _Player.AmmoGain = 0.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   0);
            // Override default settings
            if(G_InfectedPlayerCount <= S_InfectedShoot) {
                _Player.AmmoGain = S_InfectedWAmmoGain;
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   S_InfectedWLaserMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  S_InfectedWRocketMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, S_InfectedWNucleusMax);
                SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   S_InfectedWArrowMax);
            }
        }
        case 1:
        {
            _Player.AmmoGain = 1.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   1);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  4);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   3);
        }
        case 2:
        {
            _Player.AmmoGain = 10.0;
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser,   10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket,  10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
            SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow,   10);
        }
    }

    //if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
    //    SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket));
    //}
    //if(_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
    //    SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
    //}
}

Void UpdateTablePlayerStatus(CSmPlayer _Player) {
    if(!Spectators.existskey(_Player.Id)) {
        if(IsInfected(_Player)) {
            declare Ident InfectorId for _Player;
            ScoresTable::SetCustom1(_Player, C_TxtInfected);
            if(Players.existskey(InfectorId)) {
                ScoresTable::SetFooterStats(_Player, C_TxtInfectedBy ^ Players[InfectorId].Name);
            } else {
                ScoresTable::SetFooterStats(_Player, C_TxtInfectedFooter);
            }
        } else {
            ScoresTable::SetCustom1(_Player, C_TxtSurvivor);
            ScoresTable::SetFooterStats(_Player, C_TxtSurvivorFooter);
        }
    } else {
        ScoresTable::SetCustom1(_Player, C_TxtSpectator);
        ScoresTable::SetFooterStats(_Player, C_TxtSpectatorFooter);
    }
}

Void UpdateTableSurvivalTime(CSmPlayer _Player) {
    declare Integer SpawnTime     for _Player = -1;
    declare Integer InfectionTime for _Player = -1;
    if(IsInfected(_Player)) {
        declare SurvivalTime = InfectionTime - SpawnTime;
        if(SurvivalTime < 0) {
            SurvivalTime = 0;
        }
        ScoresTable::SetCustom2(_Player, TL::TimeToText(SurvivalTime, True));
    } else {
        ScoresTable::SetCustom2(_Player, C_TxtUnkTime);
    }
}

Void UpdateTableScores(CSmPlayer _Player) {
    declare Round_Infections for _Player = 0;
    declare Round_Hits       for _Player = 0;
    declare Round_Survivals  for _Player = 0;

    ScoresTable::SetCustom3(_Player,
        TL::Compose("$360%1$fff/$f00%2$fff/$ff0%3",
            TL::ToText(Round_Infections),
            TL::ToText(Round_Hits),
            TL::ToText(Round_Survivals)
        )
    );
}

Void UpdateTable(CSmPlayer _Player) {
    UpdateTablePlayerStatus(_Player);
    UpdateTableSurvivalTime(_Player);
    UpdateTableScores(_Player);
}

Void UpdateModeStatusMessage() {
    ModeStatusMessage = TL::Compose(
        """Currently on the server:
-   $360%1$g infected,
-   $f00%2$g survivors, and
-   $aaa%3$g spectators.
    """,
        TL::ToText(G_InfectedPlayerCount),
        TL::ToText(Players.count - G_InfectedPlayerCount),
        TL::ToText(Spectators.count)
    );
}

Void RewardInfector(CSmPlayer _Infector, Real _Score) {
    if(_Score < 1.0)
        return;
    declare Ident InfectorId for _Infector;
    if(InfectorId != NullId && Players.existskey(InfectorId)) {
        declare _Parent = Players[InfectorId];
        Scores::AddPoints(_Parent, ML::NearestInteger(_Score));
        RewardInfector(_Parent, _Score * S_RewardInfectors);
    }
}

Void RewardSurvivorsForSurvivingInfection() {
    foreach(Survivor in Players) {
        if(IsInfected(Survivor))
            continue;

        declare Round_Survivals for Survivor = 0;
        declare Match_Survivals for Survivor = 0;
        Round_Survivals += 1;
        Match_Survivals += 1;
        Top::SetRecord(Survivor, C_TopSurivals, TL::ToText(Match_Survivals), -Match_Survivals);
        Scores::AddPoints(Survivor, S_ScoreForSurv1Inf);
        UpdateTableScores(Survivor);
    }
}

Boolean IsProtectedByMap(CSmPlayer _Player) {
    if(_Player == Null)
        return False;

    if(_Player.IsInWater) {
        if(IsInfected(_Player)) {
            return G_MapSetting_WaterForInfected_Protects;
        } else {
            return G_MapSetting_WaterForSurvivors_Protects;
        }
    }

    return False;
}

Void OnHit(CSmModeEvent _Event, Integer _Multiplier) {
    declare Match_Hits for _Event.Shooter = 0;
    declare Round_Hits for _Event.Shooter = 0;
    declare Integer Points = _Event.Damage / C_ArmorUnit * _Multiplier;
    Round_Hits += Points;
    Match_Hits += Points;
    Scores::AddPoints(_Event.Shooter, Points);
    Top::SetRecord(_Event.Shooter, C_TopHits, TL::ToText(Match_Hits), -Match_Hits);
    UpdateTableScores(_Event.Shooter);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector, Text _CauseFmt) {
    if(_Victim == Null)
        return;

    if(IsInfected(_Victim) || (_Infector != Null && !IsInfected(_Infector))) {
        log("ERROR: Infect is called with already infected victim, or not infected infector!");
        return;
    }

    declare netwrite Boolean Net_Infected     for _Victim;
    declare netwrite Real Net_NearestSurvivor for _Victim;

    declare Ident InfectorId  for _Victim;
    declare Boolean Infected  for _Victim = S_InfectNewPlayers;

    declare Integer SpawnTime     for _Victim;
    declare Integer InfectionTime for _Victim;

    Infected            = True;
    Net_Infected        = True;
    Net_NearestSurvivor = 0.0;
    if(_Infector != Null) {
        InfectorId = _Infector.Id;

        declare Match_Infections for _Infector = 0;
        declare Round_Infections for _Infector = 0;
        Round_Infections += 1;
        Match_Infections += 1;
        Top::SetRecord(_Infector, C_TopInfections, TL::ToText(Match_Infections), -Match_Infections);

        if(_Infector.Armor < _Infector.ArmorMax) {
            _Infector.Armor += S_InfectionArmorBonus;
        }
        if(S_RewardInfectors > 0) {
            RewardInfector(_Infector, S_InfectionScore * S_RewardInfectors);
        }

        Scores::AddPoints(_Infector, S_InfectionScore);
        UpdateTableScores(_Infector);

        // Notify everyone about infection
        //Message::SendStatusMessage(TL::Compose("%1$z$s infected %2$z$s!", _Infector.Name, _Victim.Name), 4000, 1);
        //Message::SendBigMessage(_Victim, "$360Infected!", 4000, 1);
    }

    G_InfectedPlayerCount += 1;

    if(_Victim.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
        if(S_RespawnOnInfection) {
            UnspawnPlayer(_Victim);
        } else {
            InitInfected(_Victim);
            SetupInfectedWeapons(_Victim);
        }
    }

    InfectionTime = Now;
    UpdateTablePlayerStatus(_Victim);
    UpdateTableSurvivalTime(_Victim);

    RewardSurvivorsForSurvivingInfection();

    // SendNotice to all players about infection
    if(_Infector != Null) {
        foreach(Player in AllPlayers) {
            declare Text Message;
            if(Player == _Infector) {
                Message = TL::Compose(C_TxtYouInfectedA, _Victim.Name);
            } else if (Player == _Victim) {
                Message = TL::Compose(C_TxtAInfectedYou, _Infector.Name);
            } else {
                Message = TL::Compose(C_TxtAInfectedB, _Infector.Name, _Victim.Name);
            }
            UIManager.GetUI(Player).SendNotice(
                Message,
                CUIConfig::ENoticeLevel::PlayerInfo,
                _Infector.User,
                CUIConfig::EAvatarVariant::Default,
                CUIConfig::EUISound::PlayerHit,
                0
            );
        }
    } else if(_CauseFmt != "") {
        UIManager.UIAll.SendNotice(
            TL::Compose(_CauseFmt, _Victim.Name),
            CUIConfig::ENoticeLevel::PlayerInfo,
            _Victim.User,
            CUIConfig::EAvatarVariant::Default,
            CUIConfig::EUISound::PlayerHit,
            0
        );
    }

    if(G_InfectedPlayerCount == Players.count - 1) {
        // Get last survivor
        declare CSmPlayer LastSurvivor = Null;
        foreach(Player in Players) {
            if(!IsInfected(Player)) {
                LastSurvivor = Player;
                break;
            }
        }
        if(LastSurvivor != Null) {
            Message::SendBigMessage(
                TL::Compose(
                    "%1$z$s is the last survivor!",
                    LastSurvivor.Name
                ),
                C_LastSurvivorMsgDuration,
                C_LastSurvivorMsgPriority
            );
        }
    }
}

Void Infect(CSmPlayer _Victim, Text _CauseFmt) {
    Infect(_Victim, Null, _CauseFmt);
}

Void Infect(CSmPlayer _Victim, CSmPlayer _Infector) {
    Infect(_Victim, _Infector, "");
}

Void Infect(CSmPlayer _Victim) {
    Infect(_Victim, Null);
}

Void EliminateByWater(CSmPlayer _Player) {
    if(_Player == Null)
        return;

    UnspawnPlayer(_Player);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_TxtPlayerDrowned,
        CUIConfig::ENoticeLevel::PlayerInfo,
        _Player.User,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::PlayerHit,
        0
    );
}

Void ManageMapWaterEffectsForInfected(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForInfected_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForInfected_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Void ManageMapWaterEffectsForSurvivor(CSmPlayer _Player) {
    declare Boolean WasInWater for _Player = False;

    if(_Player.IsInWater) {
        if(G_MapSetting_WaterForSurvivors_Eliminates) {
            EliminateByWater(_Player);
        }
        if(G_MapSetting_WaterForSurvivors_Infects) {
            if(!IsInfected(_Player)) {
                Infect(_Player, C_TxtPlayerInfectedByWater);
            }
        }
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = C_ArmorReplenishGain;
        }
    } else if(WasInWater) {
        if(G_MapSetting_WaterForSurvivors_Heals) {
            _Player.ArmorReplenishGain = 0;
        }
    }

    WasInWater = _Player.IsInWater;
}

Boolean InfectsByDistance(Vec3 _P1, Vec3 _P2) {
    return ML::Abs(_P1.X - _P2.X) <= S_HorizontalInfectionDistance &&
           ML::Abs(_P1.Y - _P2.Y) <= S_VerticalInfectionDistance &&
           ML::Abs(_P1.Z - _P2.Z) <= S_HorizontalInfectionDistance;
}

Void ManageInfectedPlayer(CSmPlayer _Infected) {
    declare netwrite Net_NearestSurvivor for _Infected = 0.0;
    declare MinDetectDist = S_SurvivorDetectorMaxDist;
    foreach(Survivor in Players) {
        if(Survivor.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
            continue;
        if(IsInfected(Survivor))
            continue;
        if(InfectsByDistance(Survivor.Position, _Infected.Position)) {
            if(!IsProtectedByMap(Survivor))
                Infect(Survivor, _Infected);
        }
        declare Real Distance = ML::Distance(Survivor.Position, _Infected.Position);
        if(Distance < MinDetectDist) {
            MinDetectDist = Distance;
        }
    }
    Net_NearestSurvivor = 1.0 - MinDetectDist / S_SurvivorDetectorMaxDist;
}

Void ManageMapLeaver(CSmPlayer _Player) {
    if(S_CanLeaveMapFor < 0) {
        return;
    }
    declare Integer LeftMapSince for _Player = -1;
    declare PlayerUI <=> UIManager.GetUI(_Player);
    if(_Player.Position.X     < 0
    || _Player.Position.Z     < 0
    || _Player.Position.X / 8 > Map.Size.X
    || _Player.Position.Z / 8 > Map.Size.Z)
    {
        if(LeftMapSince == -1) {
            LeftMapSince = Now;
        }
        if(Now - LeftMapSince < S_CanLeaveMapFor) {
            PlayerUI.BigMessage    = C_TxtGetBackToBattleField;
            PlayerUI.StatusMessage = TL::Compose(C_TxtYouWillBeInfectedInX, TL::ToText(S_CanLeaveMapFor / 1000 - ML::FloorInteger((Now - LeftMapSince) / 1000.0)));
        } else {
            Infect(_Player, C_TxtPlayerWasEliminated);
        }
    } else if(LeftMapSince != -1) {
        LeftMapSince = -1;
        PlayerUI.BigMessage    = "";
        PlayerUI.StatusMessage = "";
    }
}

Void ManageIdlePlayer(CSmPlayer _Player) {
    if(S_ForceSpecAfter <= 0) {
        return;
    }

    if(_Player.IdleDuration < S_ForceSpecAfter) {
        return;
    }

    declare Integer SpawnTime for _Player = Now;
    if(Now - SpawnTime < S_CanIdleAfterSpawn) {
        return;
    }

    Users_RequestSwitchToSpectator(_Player.User);
    UIManager.UIAll.SendChat(_Player.Name ^ C_WasIdleTooLongMovingToSpec);
    UIManager.UIAll.SendNotice(
        _Player.Name ^ C_PlayerIsIdle,
        CUIConfig::ENoticeLevel::PlayerInfo,
        Null,
        CUIConfig::EAvatarVariant::Default,
        CUIConfig::EUISound::Silence,
        0
    );
}

Void ConditionError(Text _Error) {
    declare Text Message = C_Cond_TxtPrefix ^ "Error: " ^ _Error;
    log(Message);
    UIManager.UIAll.SendChat(Message);
}

Boolean SetupLandmarkConditions(CSmMapLandmark _Landmark, Text _TextConditions) {
    declare Integer[][] Conditions for _Landmark;

    declare Text[] Split;
    declare Text[] SplitOR;
    declare Text[] SplitAND;

    SplitOR = TL::Split("|", _TextConditions);
    foreach(ORConds in SplitOR) {
        SplitAND = TL::Split("&", ORConds);
        foreach(Cond in SplitAND) {
            declare Integer CCountSource = -1;
            declare Integer CComparison  = -1;
            declare Integer CValue       = -1;
            while(True) {
                Split = TL::Split("<", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_LT;
                    break;
                }
                Split = TL::Split("=", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_EQ;
                    break;
                }
                Split = TL::Split(">", Cond);
                if(Split.count == 2) {
                    CComparison = C_Cond_Comparison_GT;
                    break;
                }
                break;
            }
            if(CComparison == -1) {
                ConditionError("Invalid comparison `" ^ Cond ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            switch(Split[0]) {
                case C_Cond_TxtPlayers   : CCountSource = C_Cond_Players;
                case C_Cond_TxtSurvivors : CCountSource = C_Cond_Survivors;
                case C_Cond_TxtInfected  : CCountSource = C_Cond_Infected;
            }
            if(CCountSource == -1) {
                ConditionError("Invalid count source `" ^ Split[0] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            CValue = TL::ToInteger(Split[1]);
            if(CValue == -1) {
                ConditionError("Invalid value `" ^ Split[1] ^ "` in condition: " ^ _TextConditions);
                continue;
            }
            Conditions.add([CCountSource, CComparison, CValue, C_Cond_Chain_AND]);
        }
        if(Conditions.count > 0) {
            Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_OR;
        }
    }
    if(Conditions.count > 0) {
        Conditions[Conditions.count - 1][C_Cond_Chain] = C_Cond_Chain_None;
    }

    return Conditions.count > 0;
}

Boolean SetupGateConditions(CSmMapLandmark _Gate) {
    declare Text[] Split;
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;
    declare Boolean UpdateAlways   for _Gate = False;

    Split = TL::Split("_", _Gate.Tag);
    if(Split.count != 2) {
        return False;
    }
    if(Split[0] != "Gate") {
        return False;
    }

    Split = TL::Split(":", Split[1]);
    if(Split.count != 3) {
        return False;
    }

    UpdateAlways  = Split[0] == "A";
    DefaultOpened = Split[1] == "O";

    return SetupLandmarkConditions(_Gate, Split[2]);
}

Void SetupConditionalGate(CSmMapLandmark _Gate) {
    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    Gate.Automatic    = False;
    Gate.ManualClosed = True;
    Gate.Clan         = 0;
    Gauge.Clan        = 0;
    Gauge.Speed       = 0;
}

Void SetupCustomSpawn(CSmMapLandmark _Spawn) {
    declare Text[] Split;
    //declare Gauge <=> _Spawn.Gauge;

    Split = TL::Split("_", _Spawn.Tag);
    if(Split[0] != "Spawn") {
        return;
    }

    declare Boolean IsCommonSpawn = False;
    if(Split.count > 1) {
        Split = TL::Split(":", Split[1]);
        switch(Split[0]) {
            case C_Cond_TxtInfected:
            {
                G_InfectedSpawns.add(_Spawn);
                //Gauge.Clan = C_InfectedClanNum;
            }
            case C_Cond_TxtSurvivors:
            {
                G_SurvivorSpawns.add(_Spawn);
                //Gauge.Clan = C_SurvivorClanNum;
            }
            default: IsCommonSpawn = True;
        }
        if(Split.count > 1) {
            SetupLandmarkConditions(_Spawn, Split[1]);
        }
    } else {
        IsCommonSpawn = True;
    }
    if(IsCommonSpawn) {
        // Add to both lists, because it's common spawn
        G_InfectedSpawns.add(_Spawn);
        G_SurvivorSpawns.add(_Spawn);
        //Gauge.Clan = 0;
    }
}

Void SetupMapWaterProperties(Text _TxtProperty) {
    declare Text[] Args = TL::Split("=", _TxtProperty);
    if(Args.count != 2)
        return;
    switch(Args[0]) {
        case C_Cond_TxtSurvivors:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForSurvivors_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForSurvivors_Protects   = True;
                case C_MapSetting_WaterProperty_TxtInfects    : G_MapSetting_WaterForSurvivors_Infects    = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForSurvivors_Heals      = True;
            }
        }
        case C_Cond_TxtInfected:
        {
            switch(Args[1]) {
                case C_MapSetting_WaterProperty_TxtEliminates : G_MapSetting_WaterForInfected_Eliminates = True;
                case C_MapSetting_WaterProperty_TxtProtects   : G_MapSetting_WaterForInfected_Protects   = True;
                case C_MapSetting_WaterProperty_TxtHeals      : G_MapSetting_WaterForInfected_Heals      = True;
            }
        }
    }
    G_MapSetting_WaterHasEffects = True;
}

Void SetupMapSettings(Text _TxtSettings) {
    declare Text[] Settings = TL::Split(";", _TxtSettings);
    foreach(Setting in Settings) {
        declare Text[] Args = TL::Split(":", Setting);
        switch(Args[0]) {
            case C_MapSetting_Water: SetupMapWaterProperties(Args[1]);
        }
    }
}

Integer GetConditionalCount(Integer _Source) {
    switch(_Source) {
        case C_Cond_Players   : return Players.count;
        case C_Cond_Survivors : return Players.count - G_InfectedPlayerCount;
        case C_Cond_Infected  : return G_InfectedPlayerCount;
    }
    return 0;
}

Boolean Compare(Integer _Count, Integer _Comparison, Integer _Value) {
    switch(_Comparison) {
        case C_Cond_Comparison_LT : return _Count < _Value;
        case C_Cond_Comparison_EQ : return _Count == _Value;
        case C_Cond_Comparison_GT : return _Count > _Value;
    }
    return False;
}

Boolean ConditionsAreSatisfied(Integer[][] _Conditions) {
    declare Boolean Result = True;
    declare Integer PrevChain = C_Cond_Chain_None;
    foreach(Condition in _Conditions) {
        declare CurrentResult = Compare(
            GetConditionalCount(Condition[C_Cond_CountSource]),
            Condition[C_Cond_Comparison],
            Condition[C_Cond_Value]
        );
        switch(PrevChain) {
            case C_Cond_Chain_AND : Result = Result && CurrentResult;
            case C_Cond_Chain_OR  : Result = Result || CurrentResult;
            case C_Cond_Chain_None: Result = CurrentResult;
            default:
            {
                // This must not happen
                log(TL::Compose(C_UnexpectedBehaviour, "ConditionsAreSatisfied", "" ^ PrevChain));
                Result = False;
            }
        }
        PrevChain = Condition[C_Cond_Chain];
    }
    return Result;
}

Void UpdateGateStatus(CSmMapLandmark _Gate, Boolean _CanClose) {
    declare Integer[][] Conditions for _Gate;
    declare Boolean DefaultOpened  for _Gate = False;

    declare Gate  <=> _Gate.Gate;
    declare Gauge <=> _Gate.Gauge;

    // Permit only opening gates during the round
    if(!_CanClose && !Gate.ManualClosed)
        return;

    declare Open = DefaultOpened;
    if(ConditionsAreSatisfied(Conditions)) {
        // Toggle `Open` status if the conditions are satisfied
        Open = !Open;
    }

    if(Open) {
        Gauge.ValueReal = 0.0;
    } else {
        Gauge.ValueReal = 1.0;
    }
    Gauge.Captured = !Open;
    Gate.ManualClosed = !Open;
}

CSmMapLandmark[] GetPermittedSpawns(CSmMapLandmark[] _Spawns) {
    declare CSmMapLandmark[] PermittedSpawns;
    foreach(Spawn in _Spawns) {
        declare Integer[][] Conditions for Spawn;
        if(Conditions.count > 0) {
            if(!ConditionsAreSatisfied(Conditions))
                continue;
        }
        PermittedSpawns.add(Spawn);
    }
    return PermittedSpawns;
}

Void SpawnAndInitPlayer(CSmMapPlayerSpawn _Spawn, CSmPlayer _Player) {
    declare Boolean Infected  for _Player = False;
    declare Integer SpawnTime for _Player = -1;
    declare Integer ClanNum = 0;

    if(SpawnTime == -1) {
        SpawnTime = Now + S_RespawnDelay;
    }

    if(!Infected) {
        // Survivor
        InitSurvivor(_Player);
        if(S_UseClans) {
            ClanNum = C_SurvivorClanNum;
        }
    } else {
        // Infected
        InitInfected(_Player);
        if(S_UseClans) {
            ClanNum = C_InfectedClanNum;
        }
    }

    if(G_MapSetting_WaterForSurvivors_Heals || G_MapSetting_WaterForInfected_Heals) {
        // Reset ArmorReplenishGain if Player respawned in water,
        // otherwise player could get an additional armor because of
        // G_MapSetting_WaterFor..._Heals
        _Player.ArmorReplenishGain = 0;
    }

    SM::SpawnPlayer(_Player, ClanNum, _Player.Armor, _Spawn, SpawnTime);

    // Weapons setup
    // can be done only after spawn :(
    if(!Infected) {
        // Survivor
        SetupSurvivorWeapons(_Player);
    } else {
        // Infected
        SetupInfectedWeapons(_Player);
    }
}

Void SpawnAndInitPlayers(CSmPlayer[] _Players, Boolean _CanInfect) {
    declare CSmMapLandmark[] SurvivorSpawns = GetPermittedSpawns(G_SurvivorSpawns);
    declare CSmMapLandmark[] InfectedSpawns = GetPermittedSpawns(G_InfectedSpawns);
    foreach(Player in _Players) {
        if(_CanInfect && C_InfectOnRespawn && !IsInfected(Player)) {
            Infect(Player);
        }

        declare CSmMapLandmark[] Spawns;
        if(IsInfected(Player)) {
            Spawns = InfectedSpawns;
        } else {
            Spawns = SurvivorSpawns;
        }
        SpawnAndInitPlayer(
            Spawns[ML::Rand(0, Spawns.count - 1)].PlayerSpawn,
            Player
        );
    }
}

Text GenerateManialink() {
    return """
        <label style="TextRaceChrono" posn="120 -69" valign="center" halign="right" textcolor="{{{TL::ColorToText(C_InfectedColor)}}}" text="{{{G_InfectedPlayerCount}}}" id="Infected"/>
        <label style="TextRaceChrono" posn="121 -72" valign="center" halign="center" textcolor="fff" text="/" />
        <label style="TextRaceChrono" posn="122 -75" valign="center" halign="left" textcolor="fff" text="{{{Players.count}}}" id="Players"/>
        <label posn="128 -76" valign="center" halign="left" textcolor="fff" text="infected" />

        <label style="TextTitle1" posn="0 20" halign="center" visible="false" textcolor="f00" id="Idle_Text">{{{C_IdlePlayerWarning}}}</label>
        <label style="TextRaceChrono" posn="0 15" halign="center" visible="false" id="Idle_Time" />

        <frame id="NearestSurvivorFrame">
            <frame>
                <gauge posn="-21 -87" ratio="0.5" clan="{{{C_InfectedClanNum}}}" sizen="53 8" rot="180" id="NearestSurvivor" />
                <quad posn="-27 -76 10" sizen="14 14" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" />
                <quad posn="-26 -77 11" sizen="12 12" image="file:///Media/Manialinks/ShootMania/Common/MainPlayer.dds" id="SurvivorImage" />
            </frame>
            <quad posn="-0.3 0.3 0" sizen="0.6 0.6" bgcolor="fff" />
        </frame>
        <script>
        <!--
        {{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
        {{{Manialink::Animations(["EaseInOutQuad"])}}}
        main() {
            wait(InputPlayer != Null);

            declare netread Net_InfectedCount   for Teams[0] = 0;
            declare netread Net_PlayerCount     for Teams[0] = 0;
            declare netread Net_Infected        for InputPlayer = False;
            declare netread Net_NearestSurvivor for InputPlayer = 0.0;

            declare Real NearestSurvivor = 0.0;
            declare Boolean IsSpawned = False;

            declare Label_Infected        = (Page.GetFirstChild("Infected")             as CMlLabel);
            declare Label_Players         = (Page.GetFirstChild("Players")              as CMlLabel);
            declare Label_Idle_Text       = (Page.GetFirstChild("Idle_Text")            as CMlLabel);
            declare Label_Idle_Time       = (Page.GetFirstChild("Idle_Time")            as CMlLabel);
            declare Frame_NearestSurvivor = (Page.GetFirstChild("NearestSurvivorFrame") as CMlFrame);

            while(True) {
                yield;

                IsSpawned = InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned;

                Label_Infected.Value = TL::ToText(Net_InfectedCount);
                Label_Players.Value  = TL::ToText(Net_PlayerCount);

                Frame_NearestSurvivor.Visible = Net_Infected && IsSpawned;
                if(Frame_NearestSurvivor.Visible) {
                    LibManialink_AnimLoop();
                    if(NearestSurvivor != Net_NearestSurvivor) {
                        NearestSurvivor = Net_NearestSurvivor;

                        declare Intensity = 0.5 + NearestSurvivor / 2.0;
                        LibManialink_Anim("<gauge id=\"NearestSurvivor\" ratio=\"" ^ ML::Clamp(NearestSurvivor, 0.0, 1.0) ^ "\" />", 200, "EaseInOutQuad");
                        LibManialink_Anim("<quad id=\"SurvivorImage\" colorize=\"" ^ TL::ColorToText(<0.0, Intensity, 0.0>) ^ "\" />", 200, "EaseInOutQuad");
                    }
                }

                if({{{S_ForceSpecAfter > 0}}}) {
                    if(IsSpawned && InputPlayer.IdleDuration >= {{{S_ForceSpecAfter * 0.8}}}) {
                        declare Integer TimeLeft = {{{S_ForceSpecAfter}}} - InputPlayer.IdleDuration;
                        Label_Idle_Text.Opacity  = 0.5 + 0.5 * ML::Sin(Now / (50.0 * ML::PI()));
                        Label_Idle_Text.Visible  = True;
                        if(TimeLeft >= 0) {
                            Label_Idle_Time.Value = TL::TimeToText(TimeLeft);
                        }
                        Label_Idle_Time.Visible = TimeLeft >= 0;
                    } else {
                        Label_Idle_Text.Visible = False;
                        Label_Idle_Time.Visible = False;
                    }
                }
            }
        }
        -->
        </script>""";
}

